

题目0:
数据结构概念包括数据之间的逻辑结构、数据在计算机中的存储方式和数据的运算三个方面。
选项： T F
答案：T




题目1:
2N2^N2N和 N^N具有相同的增长速度。
选项： T F
答案：F




题目2:
For the following piece of code 
if ( A > B ){     
  for ( i=0; i<N*2; i++ )         
    for ( j=N*N; j>i; j-- )             
      C += A; 
}
else {     
  for ( i=0; i<N*N/100; i++ )         
    for ( j=N; j>i; j-- ) 
      for ( k=0; k<N*3; k++)
        C += B; 
} the lowest upper bound of the time complexity is O(N3)O(N^3)O(N3).
选项： T F
答案：T




题目3:
对于顺序存储的长度为 N的线性表，访问结点和增加结点的时间复杂度分别对应为 O(1)O(1)O(1)和 O(N)O(N)O(N)。
选项： T F
答案：T




题目4:
若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存储最节省时间。
选项： T F
答案：T




题目5:
在具有 N个结点的单链表中，访问结点和增加结点的时间复杂度分别对应为 O(1)O(1)O(1)和 O(N)O(N)O(N)。
选项： T F
答案：F




题目6:
将 N个数据按照从小到大顺序组织存放在一个单向链表中。如果采用二分查找，那么查找的平均时间复杂度是 O(logN)O(logN)O(logN)。
选项： T F
答案：F




题目7:
通过对堆栈S操作：Push(S,1), Push(S,2), Pop(S), Push(S,3), Pop(S), Pop(S)。输出的序列为：123。
选项： T F
答案：F




题目8:
所谓“循环队列”是指用单向循环链表或者循环数组表示的队列。
选项： T F
答案：F




题目9:
若一个栈的输入序列为1，2，3，…， N，输出序列的第一个元素是 iii，则第 jjj个输出元素是 j?i?1j-i-1j?i?1。
选项： T F
答案：F




题目10:
对于顺序存储的长度为 N的线性表，删除第一个元素和插入最后一个元素的时间复杂度分别对应为 O(1)O(1)O(1)和 O(N)O(N)O(N)。
选项： T F
答案：F




题目11:
在用数组表示的循环队列中，front值一定小于等于rear值。
选项： T F
答案：F




题目12:
若一个栈的输入序列为{1, 2, 3, 4, 5}，则不可能得到{3, 4, 1, 2, 5}这样的出栈序列。
选项： T F
答案：T




题目13:
若用链表来表示一个线性表，则表中元素的地址一定是连续的。
选项： T F
答案：F




题目14:
任何最小堆的前序遍历结果是有序的（从小到大）。
选项： T F
答案：F




题目15:
任何最小堆中从根结点到任一叶结点路径上的所有结点是有序的（从小到大）。
选项： T F
答案：T




题目16:
任何二叉搜索树中同一层的结点从左到右是有序的（从小到大）。
选项： T F
答案：T




题目17:
某二叉树的前序和中序遍历序列正好一样，则该二叉树中的任何结点一定都无左孩子。
选项： T F
答案：T




题目18:
已知一棵二叉树的先序遍历结果是ABC,　则CAB不可能是中序遍历结果。
选项： T F
答案：T




题目19:
一棵有124个结点的完全二叉树，其叶结点个数是确定的。
选项： T F
答案：T




题目20:
二叉搜索树的查找和折半查找的时间复杂度相同。
选项： T F
答案：F




题目21:
若一个结点是某二叉树的中序遍历序列的最后一个结点，则它必是该树的前序遍历序列中的最后一个结点。
选项： T F
答案：F




题目22:
某二叉树的后序和中序遍历序列正好一样，则该二叉树中的任何结点一定都无左孩子。
选项： T F
答案：F




题目23:
存在一棵总共有2016个结点的二叉树，其中有16个结点只有一个孩子。
选项： T F
答案：F




题目24:
将一棵完全二叉树存于数组中（根结点的下标为1）。则下标为23和24的两个结点是兄弟。
选项： T F
答案：F




题目25:
在有 N个元素的最大堆中，随机访问任意键值的操作可以在 O(logN)O(logN)O(logN)时间完成。
选项： T F
答案：F




题目26:
无向连通图所有顶点的度之和为偶数。
选项： T F
答案：T




题目27:
无向连通图边数一定大于顶点个数减1。
选项： T F
答案：F




题目28:
用邻接表法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。
选项： T F
答案：F




题目29:
无向连通图至少有一个顶点的度为1。
选项： T F
答案：F




题目30:
在一个有向图中，所有顶点的入度与出度之和等于所有边之和的2倍。
选项： T F
答案：T




题目31:
在任一有向图中，所有顶点的入度之和等于所有顶点的出度之和。
选项： T F
答案：T




题目32:
如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G中一定有回路。
选项： T F
答案：F




题目33:
如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G一定有2个连通分量。
选项： T F
答案：T




题目34:
用一维数组G[]存储有4个顶点的无向图如下： G[] = { 0, 1, 0, 1, 1, 0, 0, 0, 1, 0 } 则顶点2和顶点0之间是有边的。
选项： T F
答案：T




题目35:
在一个有权无向图中，若b到a的最短路径距离是12，且c到b之间存在一条权为2的边，则c到a的最短路径距离一定不小于10。
选项： T F
答案：T




题目36:
无向图中的一条边，在其邻接表存储结构中对应两个弧结点。
选项： T F
答案：T




题目37:
Kruskal 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。
选项： T F
答案：F




题目38:
有向图的邻接矩阵是对称的。
选项： T F
答案：F




题目39:
对于带权无向图 G = (V, E)，M 是 G 的最小生成树，则 M 中任意两点 V1 到 V2 的路径一定是它们之间的最短路径。
选项： T F
答案：F




题目40:
对 N个记录进行堆排序，需要的额外空间为 O(N)O(N)O(N)。
选项： T F
答案：F




题目41:
对 N个记录进行简单选择排序，比较次数和移动次数分别为 O(N2)O(N^2)O(N2)和 O(N)O(N)O(N)。
选项： T F
答案：T




题目42:
对 N个记录进行快速排序，在最坏的情况下，其时间复杂度是 O(NlogN)O(NlogN)O(NlogN)。
选项： T F
答案：F




题目43:
希尔排序是稳定的算法。
选项： T F
答案：F




题目44:
对N个不同的数据采用冒泡排序进行从大到小的排序，当元素基本有序时交换元素次数肯定最多。
选项： T F
答案：F




题目45:
要从50个键值中找出最大的3个值，选择排序比堆排序快。
选项： T F
答案：T




题目46:
采用平方探测冲突解决策略（ hi(k)=(H(k)+i2)%11h_i(k) = (H(k) + i^2) %11hi(k)=(H(k)+i2)%11, 注意：不是 ±i2\pm i^2±i2），将一批散列值均等于2的对象连续插入一个大小为11的散列表中，那么第4个对象一定位于下标为0的位置。
选项： T F
答案：T




题目47:
将 MMM个元素存入用长度为 SSS的数组表示的散列表，则该表的装填因子为 M/SM/SM/S。
选项： T F
答案：T




题目48:
在散列中，函数“插入”和“查找”具有同样的时间复杂度。
选项： T F
答案：T




题目49:
即使把2个元素散列到有100个单元的表中，仍然有可能发生冲突。
选项： T F
答案：T




题目50:
被计算机加工的数据元素不是孤立的，它们彼此之间一般存在某种关系，通常把数据元素之间的这种关系称为
选项： A. 规则 B. 结构 C. 集合 D. 运算
答案：B. 结构




题目51:
从逻辑上可将数据结构分为（ ）。
选项： A. 动态结构和静态结构 B. 紧凑结构和非紧凑结构 C. 内部结构和外部结构 D. 线性结构和非线性结构
答案：D. 线性结构和非线性结构




题目52:
给定程序时间复杂度的递推公式： T(1)=1T(1)=1T(1)=1， T(N)=2T(N/2)+NT(N)=2T(N/2)+NT(N)=2T(N/2)+N。则程序时间复杂度是：
选项： A. O(logN)O(logN)O(logN) B. O(N)O(N)O(N) C. O(NlogN)O(NlogN)O(NlogN) D. O(N2)O(N^2)O(N2)
答案：C. O(NlogN)O(NlogN)O(NlogN)




题目53:
通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（ ）。
选项： A. 数据在同一范围内取值 B. 不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致 C. 每个数据元素都一样 D. 数据元素所包含的数据项的个数要相等
答案：B. 不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致




题目54:
下面代码段的时间复杂度是（）。 for ( i=0; i<n; i++ )
    for ( j=0; j<m; j++ )
        a[i][j]=0;
选项： A. O(1)O(1)O(1) B. O(mn)O(mn)O(mn) C. O(m2)O(m^2)O(m2) D. O(n2)O(n^2)O(n2)
答案：B. O(mn)O(mn)O(mn)




题目55:
对于顺序存储的长度为 N的线性表，访问结点和增加结点的时间复杂度为：
选项： A. O(1)O(1)O(1), O(1)O(1)O(1) B. O(1)O(1)O(1), O(N)O(N)O(N) C. O(N)O(N)O(N), O(1)O(1)O(1) D. O(N)O(N)O(N), O(N)O(N)O(N)
答案：B. O(1)O(1)O(1), O(N)O(N)O(N)




题目56:
在 N个结点的顺序表中，算法的时间复杂度为O(1)的操作是：
选项： A. 访问第 iii个结点（ 1≤i≤N1\le i\le N1≤i≤N）和求第 iii个结点的直接前驱（ 2≤i≤N2\le i\le N2≤i≤N） B. 在第 iii个结点后插入一个新结点（ 1≤i≤N1\le i\le N1≤i≤N） C. 删除第 iii个结点（ 1≤i≤N1\le i\le N1≤i≤N） D. 将 N个结点从小到大排序
答案：A. 访问第 iii个结点（ 1≤i≤N1\le i\le N1≤i≤N）和求第 iii个结点的直接前驱（ 2≤i≤N2\le i\le N2≤i≤N）




题目57:
若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用哪种存储方式最节省时间？
选项： A. 双链表 B. 单循环链表 C. 带头结点的双循环链表 D. 顺序表
答案：D. 顺序表




题目58:
线性表若采用链式存储结构时，要求内存中可用存储单元的地址
选项： A. 必须是连续的 B. 连续或不连续都可以 C. 部分地址必须是连续的 D. 一定是不连续的
答案：B. 连续或不连续都可以




题目59:
在具有 N个结点的单链表中，实现下列哪个操作，其算法的时间复杂度是 O(N)O(N)O(N)？
选项： A. 在地址为 ppp的结点之后插入一个结点 B. 删除开始结点 C. 遍历链表和求链表的第 iii个结点 D. 删除地址为 ppp的结点的后继结点
答案：C. 遍历链表和求链表的第 iii个结点




题目60:
某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用什么存储方式最节省运算时间？
选项： A. 单链表 B. 仅有尾指针的单循环链表 C. 仅有头指针的单循环链表 D. 双链表
答案：B. 仅有尾指针的单循环链表




题目61:
将线性表La和Lb头尾连接，要求时间复杂度为O(1)，且占用辅助空间尽量小。应该使用哪种结构？
选项： A. 单链表 B. 单循环链表 C. 带尾指针的单循环链表 D. 带头结点的双循环链表
答案：C. 带尾指针的单循环链表




题目62:
线性表L在什么情况下适用于使用链式结构实现？
选项： A. 需不断对L进行删除插入 B. 需经常修改L中的结点值 C. L中含有大量的结点 D. L中结点结构复杂
答案：A. 需不断对L进行删除插入




题目63:
对于一个具有 N个结点的单链表，在给定值为 xxx的结点后插入一个新结点的时间复杂度为
选项： A. O(1)O(1)O(1) B. O(N/2)O(N/2)O(N/2) C. O(N)O(N)O(N) D. O(N2)O(N^2)O(N2)
答案：C. O(N)O(N)O(N)




题目64:
链表不具有的特点是：
选项： A. 插入、删除不需要移动元素 B. 方便随机访问任一元素 C. 不必事先估计存储空间 D. 所需空间与线性长度成正比
答案：B. 方便随机访问任一元素




题目65:
设h为不带头结点的单向链表。在h的头上插入一个新结点t的语句是：
选项： A. h=t; t->next=h->next; B. t->next=h->next; h=t; C. h=t; t->next=h; D. t->next=h; h=t;
答案：D. t->next=h; h=t;




题目66:
在单链表中，若p所指的结点不是最后结点，在p之后插入s所指结点，则执行
选项： A. s->next=p; p->next=s; B. s->next=p->next; p=s; C. s->next=p->next; p->next=s; D. p->next=s; s->next=p;
答案：C. s->next=p->next; p->next=s;




题目67:
在双向链表存储结构中，删除p所指的结点，相应语句为：
选项： A. p->prior=p->prior->prior; p->prior->next=p; B. p->next->prior=p; p->next=p->next->next; C. p->prior->next=p->next; p->next->prior=p->prior; D. p->next=p->prior->prior; p->prior=p->next->next;
答案：C. p->prior->next=p->next; p->next->prior=p->prior;




题目68:
将两个结点数都为 N且都从小到大有序的单向链表合并成一个从小到大有序的单向链表，那么可能的最少比较次数是：
选项： A. 111 B. N C. 2N2N2N D. NlogNNlogNNlogN
答案：B. N




题目69:
设栈S和队列Q的初始状态均为空，元素a、b、c、d、e、f、g依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是b、d、c、f、e、a、g，则栈S的容量至少是：
选项： A. 1 B. 2 C. 3 D. 4
答案：C. 3




题目70:
有六个元素以6、5、4、3、2、1的顺序进栈，问哪个不是合法的出栈序列？
选项： A. 2 3 4 1 5 6 B. 3 4 6 5 2 1 C. 5 4 3 6 1 2 D. 4 5 3 1 2 6
答案：B. 3 4 6 5 2 1




题目71:
设一个堆栈的入栈顺序是1、2、3、4、5。若第一个出栈的元素是4，则最后一个出栈的元素必定是：
选项： A. 1 B. 3 C. 5 D. 1或者5
答案：D. 1或者5




题目72:
表达式a*(b+c)-d的后缀表达式是：
选项： A. a b c + * d - B. a b c d * + - C. a b c * + d - D. - + * a b c d
答案：A. a b c + * d -




题目73:
从栈顶指针为ST的链栈中删除一个结点且用X保存被删结点的值，则执行：
选项： A. X= ST->data; B. X= ST; ST = ST->next; C. X= ST->data; ST = ST->next; D. ST = ST->next; X= ST->data;
答案：C. X= ST->data; ST = ST->next;




题目74:
若栈采用顺序存储方式存储，现两栈共享空间V[m]：top[i]代表第i（i=1或2）个栈的栈顶；栈1的底在V[0]，栈2的底在V[m-1]，则栈满的条件是：
选项： A. |top[2]-top[1]|==0 B. top[1]+top[2]==m C. top[1]==top[2] D. top[1]+1==top[2]
答案：D. top[1]+1==top[2]




题目75:
为解决计算机主机与打印机之间速度不匹配问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是？
选项： A. 堆栈 B. 队列 C. 树 D. 图
答案：B. 队列




题目76:
某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素a、b、c、d、e依次入此队列后再进行出队操作，则不可能得到的出队序列是：
选项： A. b a c d e B. d b a c e C. e c b a d D. d b c a e
答案：D. d b c a e




题目77:
线性表、堆栈、队列的主要区别是什么？
选项： A. 线性表用指针，堆栈和队列用数组 B. 堆栈和队列都是插入、删除受到约束的线性表 C. 线性表和队列都可以用循环链表实现，但堆栈不能 D. 堆栈和队列都不是线性结构，而线性表是
答案：B. 堆栈和队列都是插入、删除受到约束的线性表




题目78:
下列关于栈的叙述中，错误的是： 采用非递归方式重写递归程序时必须使用栈 函数调用时，系统要用栈保存必要的信息 只要确定了入栈次序，即可确定出栈次序 栈是一种受限的线性表，允许在其两端进行操作
选项： A. 仅 1 B. 仅 1、2、3 C. 仅 1、3、4 D. 仅 2、3、4
答案：C. 仅 1、3、4




题目79:
设有一个 12 ×\times×12 的对称矩阵 MMM，将其上三角部分的元素 mi,jm_{i,j}mi,j（ 1≤i≤j≤121\le i\le j\le 121≤i≤j≤12）按行优先存入C语言的一维数组N中，元素 m6,6m_{6,6}m6,6在N中的下标是：
选项： A. 50 B. 51 C. 55 D. 66
答案：A. 50




题目80:
树最适合于用来表示
选项： A. 有序数据元素 B. 无序数据元素 C. 元素之间无联系的数据 D. 元素之间具有分支层次关系的数据
答案：D. 元素之间具有分支层次关系的数据




题目81:
对二叉搜索树进行什么遍历可以得到从小到大的排序序列？
选项： A. 前序遍历 B. 后序遍历 C. 中序遍历 D. 层次遍历
答案：C. 中序遍历




题目82:
在有 N个结点且为完全二叉树的二叉搜索树中查找一个键值，其平均比较次数的数量级为：
选项： A. O(logN)O(logN)O(logN) B. O(N)O(N)O(N) C. O(NlogN)O(NlogN)O(NlogN) D. O(N2)O(N^2)O(N2)
答案：A. O(logN)O(logN)O(logN)




题目83:
堆的形状是一棵：
选项： A. 二叉搜索树 B. 满二叉树 C. 非二叉树 D. 完全二叉树
答案：D. 完全二叉树




题目84:
创建一个初始堆，含有 N个记录，其时间复杂度是：
选项： A. O(logN)O(logN)O(logN) B. O(N)O(N)O(N) C. O(NlogN)O(NlogN)O(NlogN) D. O(N2)O(N^2)O(N2)
答案：B. O(N)O(N)O(N)




题目85:
哪种树，树中任何结点到根结点路径上的各结点值是有序的？
选项： A. 二叉搜索树 B. 完全二叉树 C. 堆 D. 以上都不是
答案：C. 堆




题目86:
在任一有向图中，所有顶点的入度之和与所有顶点的出度之和的关系是：
选项： A. 相等 B. 大于等于 C. 小于等于 D. 不确定
答案：A. 相等




题目87:
设无向图的顶点个数为 N，则该图最多有多少条边？
选项： A. N?1N-1N?1 B. N(N?1)/2N(N-1)/2N(N?1)/2 C. N(N+1)/2N(N+1)/2N(N+1)/2 D. N2N^2N2
答案：B. N(N?1)/2N(N-1)/2N(N?1)/2




题目88:
图的深度优先遍历类似于二叉树的：
选项： A. 先序遍历 B. 中序遍历 C. 后序遍历 D. 层次遍历
答案：A. 先序遍历




题目89:
数据结构中Dijkstra算法用来解决哪个问题？
选项： A. 关键路径 B. 最短路径 C. 拓扑排序 D. 字符串匹配
答案：B. 最短路径




题目90:
任何一个带权无向连通图的最小生成树――
选项： A. 是唯一的 B. 是不唯一的 C. 有可能不唯一 D. 有可能不存在
答案：C. 有可能不唯一




题目91:
图的广度优先遍历类似于二叉树的：
选项： A. 先序遍历 B. 中序遍历 C. 后序遍历 D. 层次遍历
答案：D. 层次遍历




题目92:
给定有向图的邻接矩阵如下： 顶点2（编号从0开始）的出度和入度分别是：
选项： A. 3, 1 B. 1, 3 C. 0, 2 D. 2, 0
答案：C. 0, 2




题目93:
(neuDS)具有6个顶点的无向图至少应有（）条边才能确保是一个连通图。
选项： A. 5 B. 6 C. 7 D. 8
答案：A. 5




题目94:
(neuDS)对某个无向图的邻接矩阵来说，下列叙述正确的是（）。
选项： A. 第i行上的非零元素个数和第i列上的非零元素个数一定相等 B. 矩阵中的非零元素个数等于图中的边数 C. 第i行与第i列上的非零元素的总数等于顶点 viv_{i}vi的度数 D. 矩阵中非全零行的行数等于图中的顶点数
答案：A. 第i行上的非零元素个数和第i列上的非零元素个数一定相等




题目95:
具有5个顶点的有向完全图有多少条弧？
选项： A. 10 B. 16 C. 20 D. 25
答案：C. 20




题目96:
具有 N（ N>0N>0N>0）个顶点的无向图至少有多少个连通分量？
选项： A. 0 B. 1 C. N?1N-1N?1 D. N
答案：B. 1




题目97:
具有 N（ N>0N>0N>0）个顶点的无向图至多有多少个连通分量？
选项： A. 0 B. 1 C. N?1N-1N?1 D. N
答案：D. N




题目98:
对于有向图，其邻接矩阵表示比邻接表表示更易于：
选项： A. 求一个顶点的入度 B. 求一个顶点的出边邻接点 C. 进行图的深度优先遍历 D. 进行图的广度优先遍历
答案：A. 求一个顶点的入度




题目99:
在用邻接表表示有 N个结点 EEE条边的图时，深度优先遍历算法的时间复杂度为：
选项： A. O(N)O(N)O(N) B. O(N+E)O(N+E)O(N+E) C. O(N2)O(N^2)O(N2) D. O(N2×E)O(N^2\times E)O(N2×E)
答案：B. O(N+E)O(N+E)O(N+E)




题目100:
在图中自a点开始进行深度优先遍历算法可能得到的结果为：
选项： A. a, b, e, c, d, f B. a, c, f, e, b, d C. a, e, b, c, f, d D. a, e, d, f, c, b
答案：D. a, e, d, f, c, b




题目101:
在图中自c点开始进行广度优先遍历算法可能得到的结果为：
选项： A. c,a,b,e,f,d B. c,a,f,d,e,b C. c,f,a,d,e,b D. c,f,a,b,d,e
答案：C. c,f,a,d,e,b




题目102:
给定一有向图的邻接表如下。从顶点V1出发按广度优先搜索法进行遍历，则得到的一种顶点序列为：
选项： A. V1,V2,V3,V4,V5 B. V1,V2,V3,V5,V4 C. V1,V3,V2,V4,V5 D. V1,V4,V3,V5,V2
答案：C. V1,V3,V2,V4,V5




题目103:
下面给出的有向图中，有__个强连通分量。
选项： A. 1 ({0,1,2,3,4}) B. 1 ({1,2,3,4}) C. 2 ({1,2,3,4}, {0}) D. 5 ({0}, {1}, {2}, {3}, {4})
答案：C. 2 ({1,2,3,4}, {0})




题目104:
给定一有向图的邻接表如下。从顶点V1出发按深度优先搜索法进行遍历，则得到的一种顶点序列为：
选项： A. V1,V2,V3,V4,V7,V6,V5 B. V1,V5,V4,V7,V6,V2,V3 C. V1,V5,V6,V4,V7,V2,V3 D. V1,V5,V4,V7,V6,V3,V2
答案：D. V1,V5,V4,V7,V6,V3,V2




题目105:
使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是：
选项： A. 5, 2, 3, 4, 6 B. 5, 2, 3, 6, 4 C. 5, 2, 4, 3, 6 D. 5, 2, 6, 3, 4
答案：B. 5, 2, 3, 6, 4




题目106:
已知图的邻接表如下所示 ，则从顶点v 1_11出发按广度优先遍历的结果是。
选项： A. v 0_00 v 1_11 v 3_33 v 2_22 B. v 1_11 v 0_00 v 2_22 v 3_33 C. v 1_11 v 0_00 v 3_33 v 2_22 D. v 0_00 v 1_11 v 2_22 v 3_33
答案：B. v 1_11 v 0_00 v 2_22 v 3_33




题目107:
给定无向图G，从V0出发进行深度优先遍历访问的边集合为： {(V0,V1), (V0,V4), (V1,V2), (V1,V3), (V4,V5), (V5,V6)}。则下面哪条边不可能出现在G中？
选项： A. (V0,V2) B. (V0,V6) C. (V1,V5) D. (V4,V6)
答案：C. (V1,V5)




题目108:
给定有权无向图的邻接矩阵如下，其最小生成树的总权重是：
选项： A. 8 B. 15 C. 20 D. 22
答案：A. 8




题目109:
给定有权无向图如下。关于其最小生成树，下列哪句是对的？
选项： A. 最小生成树不唯一，其总权重为23 B. 最小生成树唯一，其总权重为20 C. 边(B, F)一定在树中，树的总权重为23 D. 边(H, G)一定在树中，树的总权重为20
答案：A. 最小生成树不唯一，其总权重为23




题目110:
对 N个不同的数据采用冒泡算法进行从大到小的排序，下面哪种情况下肯定交换元素次数最多？
选项： A. 从小到大排好的 B. 从大到小排好的 C. 元素无序 D. 元素基本有序
答案：A. 从小到大排好的




题目111:
对 N个元素采用简单选择排序，比较次数和移动次数分别为：
选项： A. O(N2)O(N^2)O(N2), O(N)O(N)O(N) B. O(N)O(N)O(N), O(logN)O(logN)O(logN) C. O(logN)O(logN)O(logN), O(N2)O(N^2)O(N2) D. O(NlogN)O(NlogN)O(NlogN), O(NlogN)O(NlogN)O(NlogN)
答案：A. O(N2)O(N^2)O(N2), O(N)O(N)O(N)




题目112:
对一组数据（84，47，25，15，21）排序，数据的排列次序在排序的过程中的变化为: 初始序列 84 47 25 15 21 第一趟排序结果 15 47 25 84 21 第二趟排序结果15 21 25 84 47 第三趟排序结果15 21 25 84 47 则采用的排序是 ( )。
选项： A. 选择排序 B. 冒泡排序 C. 快速排序 D. 插入排序
答案：A. 选择排序




题目113:
设有100个元素的有序序列，如果用二分插入排序再插入一个元素，则最大比较次数是：
选项： A. 7 B. 10 C. 25 D. 50
答案：A. 7




题目114:
对于序列{ 49，38，65，97，76，13，27，50 }，按由小到大进行排序，下面哪一个是初始步长为4的希尔排序法第一趟的结果？
选项： A. 13,27,38,49,50,65,76,97 B. 49,13,27,50,76,38,65,97 C. 49,76,65,13,27,50,97,38 D. 97,76,65,50,49,38,27,13
答案：B. 49,13,27,50,76,38,65,97




题目115:
对 N个记录进行堆排序，最坏的情况下时间复杂度是：
选项： A. O(logN)O(logN)O(logN) B. O(N)O(N)O(N) C. O(NlogN)O(NlogN)O(NlogN) D. O(N2)O(N^2)O(N2)
答案：C. O(NlogN)O(NlogN)O(NlogN)




题目116:
对 N个记录进行堆排序，需要的额外空间为：
选项： A. O(1)O(1)O(1) B. O(logN)O(logN)O(logN) C. O(N)O(N)O(N) D. O(NlogN)O(NlogN)O(NlogN)
答案：A. O(1)O(1)O(1)




题目117:
有组记录的排序码为{46，79，56，38，40，84 }，采用快速排序（以位于最左位置的对象为基准而）得到的第一次划分结果为：
选项： A. {38,46,79,56,40,84} B. {38,79,56,46,40,84} C. {38,46,56,79,40,84} D. {40,38,46,56,79,84}
答案：D. {40,38,46,56,79,84}




题目118:
在快速排序的一趟划分过程中，当遇到与基准数相等的元素时，如果左右指针都会停止移动，那么当所有元素都相等时，算法的时间复杂度是多少？
选项： A. O(logN)O(logN)O(logN) B. O(N)O(N)O(N) C. O(NlogN)O(NlogN)O(NlogN) D. O(N2)O(N^2)O(N2)
答案：C. O(NlogN)O(NlogN)O(NlogN)




题目119:
在快速排序的一趟划分过程中，当遇到与基准数相等的元素时，如果左指针停止移动，而右指针在同样情况下却不停止移动，那么当所有元素都相等时，算法的时间复杂度是多少？
选项： A. O(logN)O(logN)O(logN) B. O(N)O(N)O(N) C. O(NlogN)O(NlogN)O(NlogN) D. O(N2)O(N^2)O(N2)
答案：D. O(N2)O(N^2)O(N2)




题目120:
快速排序方法在（ ）情况下最不利于发挥其长处。
选项： A. 要排序的数据量太大 B. 要排序的数据中含有多个相同值 C. 要排序的数据个数为奇数 D. 要排序的数据已基本有序
答案：D. 要排序的数据已基本有序




题目121:
在对 N个元素进行排序时，基于比较的算法中，其“最坏时间复杂度”中最好的是：
选项： A. O(logN)O(logN)O(logN) B. O(N)O(N)O(N) C. O(NlogN)O(NlogN)O(NlogN) D. O(N2)O(N^2)O(N2)
答案：C. O(NlogN)O(NlogN)O(NlogN)




题目122:
排序方法中，从未排序序列中依次取出元素与已排序序列中的元素进行比较，将其放入已排序序列的正确位置的方法称为：
选项： A. 插入排序 B. 选择排序 C. 快速排序 D. 归并排序
答案：A. 插入排序




题目123:
选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是： I、数据的规模 II、数据的存储方式 III、算法的稳定性 IV、数据的初始状态
选项： A. 仅 III B. 仅 I、II C. 仅 II、III、IV D. I、II、III、IV
答案：D. I、II、III、IV




题目124:
已知一个长度为16的顺序表L，其元素按关键字有序排列。若采用二分查找法查找一个L中不存在的元素，则关键字的比较次数最多是：
选项： A. 4 B. 5 C. 6 D. 7
答案：B. 5




题目125:
(neuDS)对线性表进行二分查找时，要求线性表必须( )
选项： A. 以顺序方式存储 B. 以顺序方式存储，且结点按关键字值有序排列 C. 以链接方式存储 D. 以链接方式存储，且结点按关键字值有序排列
答案：B. 以顺序方式存储，且结点按关键字值有序排列




题目126:
(neuDS)用二分查找法查找具有n个结点的顺序表时，查找每个结点的平均比较次数是( )
选项： A. O( n2n^2n2) B. O( nlog2nnlog_{2}nnlog2n) C. O(n) D. O(log2n)O(log_{2}n)O(log2n)
答案：D. O(log2n)O(log_{2}n)O(log2n)




题目127:
在散列表中，所谓同义词就是：
选项： A. 两个意义相近的单词 B. 具有相同散列地址的两个元素 C. 被映射到不同散列地址的一个元素 D. 被不同散列函数映射到同一地址的两个元素
答案：B. 具有相同散列地址的两个元素




题目128:
在下列查找的方法中，平均查找长度与结点个数无关的查找方法是：
选项： A. 顺序查找 B. 二分法 C. 利用哈希（散列）表 D. 利用二叉搜索树
答案：C. 利用哈希（散列）表




题目129:
对包含 N个元素的散列表进行查找，平均查找长度为：
选项： A. O(1)O(1)O(1) B. O(logN)O(logN)O(logN) C. O(N)O(N)O(N) D. 不确定
答案：D. 不确定




题目130:
将 MMM个元素存入用长度为 SSS的数组表示的散列表，则该表的装填因子为：
选项： A. S+MS+MS+M B. M?SM-SM?S C. M×SM\times SM×S D. M/SM/SM/S
答案：D. M/SM/SM/S




题目131:
设散列表的地址区间为[0,16]，散列函数为 H(Key)=Key%17H(Key)=Key%17H(Key)=Key%17。采用线性探测法处理冲突，并将关键字序列{ 26，25，72，38，8，18，59 }依次存储到散列表中。元素59存放在散列表中的地址是：
选项： A. 8 B. 9 C. 10 D. 11
答案：D. 11




题目132:
采用线性探测法解决冲突时所产生的一系列后继散列地址：
选项： A. 必须大于等于原散列地址 B. 必须小于等于原散列地址 C. 可以大于或小于但不等于原散列地址 D. 对地址在何处没有限制
答案：C. 可以大于或小于但不等于原散列地址




题目133:
给定散列表大小为11，散列函数为 H(Key)=Key%11H(Key) = Key%11H(Key)=Key%11。按照线性探测冲突解决策略连续插入散列值相同的4个元素。问：此时该散列表的平均不成功查找次数是多少？
选项： A. 1 B. 4/11 C. 21/11 D. 不确定
答案：C. 21/11




题目134:
从一个具有 NNN个结点的单链表中查找其值等于 XXX的结点时，在查找成功的情况下，需平均比较多少个结点？
选项： A. N/2N/2N/2 B. NNN C. (N?1)/2(N-1)/2(N?1)/2 D. (N+1)/2(N+1)/2(N+1)/2
答案：D. (N+1)/2(N+1)/2(N+1)/2




题目135:
本题要求实现一个函数，求链式表的表长。 函数接口定义： int Length( List L ); 其中List结构定义如下： typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode List; L是给定单链表，函数Length要返回链式表的长度。 裁判测试程序样例： #include <stdio.h>
#include <stdlib.h>

typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode List;

List Read(); /* 细节在此不表 */

int Length( List L );

int main()
{
    List L = Read();
    printf("%d\n", Length(L));
    return 0;
}

/* 你的代码将被嵌在这里 */ 输入样例： 1 3 4 5 2 -1 输出样例： 5
代码答案：
int Length( List L )
{
	int len=0;
	List list=L;
	while(list!=NULL)
	{
		len++;
		list=list->Next;
	}
	return len;
}

题目136:
本题要求实现一个函数，找到并返回链式表的第K个元素。 函数接口定义： ElementType FindKth( List L, int K ); 其中List结构定义如下： typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode List; L是给定单链表，函数FindKth要返回链式表的第K个元素。如果该元素不存在，则返回ERROR。 裁判测试程序样例： #include <stdio.h>
#include <stdlib.h>

#define ERROR -1
typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode List;

List Read(); /* 细节在此不表 */

ElementType FindKth( List L, int K );

int main()
{
    int N, K;
    ElementType X;
    List L = Read();
    scanf("%d", &N);
    while ( N-- ) {
        scanf("%d", &K);
        X = FindKth(L, K);
        if ( X!= ERROR )
            printf("%d ", X);
        else
            printf("NA ");
    }
    return 0;
}

/* 你的代码将被嵌在这里 */ 输入样例： 1 3 4 5 2 -1
6
3 6 1 5 4 2 输出样例： 4 NA 1 2 5 3
代码答案：
ElementType FindKth( List L, int K ){
    List p=L;
    int count=1;
    while(p){
        if(K==count) return p->Data;
        count++;
        p=p->Next;
    }
    return ERROR;
}

题目137:
本题要求实现一个函数，在递增的整数序列链表（带头结点）中插入一个新整数，并保持该序列的有序性。 函数接口定义： List Insert( List L, ElementType X ); 其中List结构定义如下： typedef struct Node *PtrToNode;
struct Node {
    ElementType Data; /* 存储结点数据 */
    PtrToNode   Next; /* 指向下一个结点的指针 */
};
typedef PtrToNode List; /* 定义单链表类型 */ L是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Insert要将X插入L，并保持该序列的有序性，返回插入后的链表头指针。 裁判测试程序样例： #include <stdio.h>
#include <stdlib.h>

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node {
    ElementType Data;
    PtrToNode   Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表 */

List Insert( List L, ElementType X );

int main()
{
    List L;
    ElementType X;
    L = Read();
    scanf("%d", &X);
    L = Insert(L, X);
    Print(L);
    return 0;
}

/* 你的代码将被嵌在这里 */ 输入样例： 5
1 2 4 5 6
3 输出样例： 1 2 3 4 5 6
代码答案：
List Insert( List L, ElementType X ){
	List head=L,p=L;
	List n=(List)malloc(sizeof(List));
	n->Data=X;
	n->Next=NULL;
	L=L->Next;
	if(L==NULL){
		head->Next=n;
		return head;
	}
	while(L->Data<X){
		p=L;
		L=L->Next;
		if(L==NULL) break;
	}
	p->Next=n;
	n->Next=L;
	return head;
}

题目138:
本题要求在一个数组中实现两个堆栈。 函数接口定义： Stack CreateStack( int MaxSize );
bool Push( Stack S, ElementType X, int Tag );
ElementType Pop( Stack S, int Tag ); 其中Tag是堆栈编号，取1或2；MaxSize堆栈数组的规模；Stack结构定义如下： typedef int Position;
struct SNode {
    ElementType *Data;
    Position Top1, Top2;
    int MaxSize;
};
typedef struct SNode *Stack; 注意：如果堆栈已满，Push函数必须输出“Stack Full”并且返回false；如果某堆栈是空的，则Pop函数必须输出“Stack Tag Empty”（其中Tag是该堆栈的编号），并且返回ERROR。 裁判测试程序样例： #include <stdio.h>
#include <stdlib.h>

#define ERROR 1e8
typedef int ElementType;
typedef enum { push, pop, end } Operation;
typedef enum { false, true } bool;
typedef int Position;
struct SNode {
    ElementType *Data;
    Position Top1, Top2;
    int MaxSize;
};
typedef struct SNode *Stack;

Stack CreateStack( int MaxSize );
bool Push( Stack S, ElementType X, int Tag );
ElementType Pop( Stack S, int Tag );

Operation GetOp();  /* details omitted */
void PrintStack( Stack S, int Tag ); /* details omitted */

int main()
{
    int N, Tag, X;
    Stack S;
    int done = 0;

    scanf("%d", &N);
    S = CreateStack(N);
    while ( !done ) {
        switch( GetOp() ) {
        case push: 
            scanf("%d %d", &Tag, &X);
            if (!Push(S, X, Tag)) printf("Stack %d is Full!\n", Tag);
            break;
        case pop:
            scanf("%d", &Tag);
            X = Pop(S, Tag);
            if ( X==ERROR ) printf("Stack %d is Empty!\n", Tag);
            break;
        case end:
            PrintStack(S, 1);
            PrintStack(S, 2);
            done = 1;
            break;
        }
    }
    return 0;
}

/* 你的代码将被嵌在这里 */ 输入样例： 5
Push 1 1
Pop 2
Push 2 11
Push 1 2
Push 2 12
Pop 1
Push 2 13
Push 2 14
Push 1 3
Pop 2
End 输出样例： Stack 2 Empty
Stack 2 is Empty!
Stack Full
Stack 1 is Full!
Pop from Stack 1: 1
Pop from Stack 2: 13 12 11
代码答案：
Stack CreateStack( int MaxSize )
{
    struct SNode *n=(struct SNode *)malloc(sizeof(struct SNode));
    n->Top1=-1;
    n->Top2=MaxSize;
    n->MaxSize=MaxSize;
    n->Data=(ElementType*)malloc(sizeof(ElementType)* MaxSize);
    return n;
}
bool Push( Stack S, ElementType X, int Tag )
{
    if(S->Top1+1==S->Top2)
	{
        printf("Stack Full\n");
        return false;
    }
    if(Tag==1)
	{
        S->Data[++S->Top1]=X;
    }
    else
	{
        S->Data[--S->Top2]=X; 
    }
    return true;
}
ElementType Pop( Stack S, int Tag )
{
    if(Tag==1&&S->Top1==-1||Tag==2&&S->Top2==S->MaxSize)
    {
        printf("Stack %d Empty\n",Tag);
        return ERROR;
    }
    int m;
    if(Tag==1)
    {
        m=S->Data[S->Top1];
        S->Top1--;
        return m;
    }
    else
    {
        m=S->Data[S->Top2];
        S->Top2++;
        return m;
    }
}

题目139:
如果用一个循环数组表示队列，并且只设队列头指针Front，不设尾指针Rear，而是另设Count记录队列中元素个数。请编写算法实现队列的入队和出队操作。 函数接口定义： bool AddQ( Queue Q, ElementType X );
ElementType DeleteQ( Queue Q ); 其中Queue结构定义如下： typedef int Position;
typedef struct QNode *PtrToQNode;
struct QNode {
    ElementType *Data;  /* 存储元素的数组   */
    Position Front;     /* 队列的头指针     */
    int Count;          /* 队列中元素个数   */
    int MaxSize;        /* 队列最大容量     */
};
typedef PtrToQNode Queue; 注意：如果队列已满，AddQ函数必须输出“Queue Full”并且返回false；如果队列是空的，则DeleteQ函数必须输出“Queue Empty”，并且返回ERROR。 裁判测试程序样例： #include <stdio.h>
#include <stdlib.h>

#define ERROR -1
typedef int ElementType;
typedef enum { addq, delq, end } Operation;
typedef enum { false, true } bool;
typedef int Position;
typedef struct QNode *PtrToQNode;
struct QNode {
    ElementType *Data;  /* 存储元素的数组   */
    Position Front;     /* 队列的头、尾指针 */
    int Count;          /* 队列中元素个数   */
    int MaxSize;        /* 队列最大容量     */
};
typedef PtrToQNode Queue; 

Queue CreateQueue( int MaxSize )
{
    Queue Q = (Queue)malloc(sizeof(struct QNode));
    Q->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
    Q->Front = 0;
    Q->Count = 0;
    Q->MaxSize = MaxSize;
    return Q;
}

bool AddQ( Queue Q, ElementType X );
ElementType DeleteQ( Queue Q );

Operation GetOp();  /* 裁判实现，细节不表 */

int main()
{
    ElementType X;
    Queue Q;
    int N, done = 0;

    scanf("%d", &N);
    Q = CreateQueue(N);
    while ( !done ) {
        switch( GetOp() ) {
        case addq: 
            scanf("%d", &X);
            AddQ(Q, X);
            break;
        case delq:
            X = DeleteQ(Q);
            if ( X!=ERROR ) printf("%d is out\n", X);
            break;
        case end:
            while (Q->Count) printf("%d ", DeleteQ(Q));
            done = 1;
            break;
        }
    }
    return 0;
}

/* 你的代码将被嵌在这里 */ 输入样例： 4
Del
Add 5
Add 4
Add 3
Del
Del
Add 2
Add 1
Add 0
Add 10
End 输出样例： Queue Empty
5 is out
4 is out
Queue Full
3 2 1 0
代码答案：
bool AddQ( Queue Q, ElementType X )
{
    if(Q->Count==Q->MaxSize)
    {
        printf("Queue Full\n");
        return false;
    }
    else 
    {
        Q->Count++;
        Q->Data[(Q->Count+Q->Front)%Q->MaxSize]=X;
        return true;
    }
}
ElementType DeleteQ( Queue Q )
{
    if(Q->Count==0)
    {
        printf("Queue Empty\n");
        return ERROR;
    }
    else
	{
        Q->Count--;
        Q->Front=(Q->Front+1)%Q->MaxSize;
        return Q->Data[Q->Front];
    }
}

题目140:
本题要求给定二叉树的高度。 函数接口定义： int GetHeight( BinTree BT ); 其中BinTree结构定义如下： typedef struct TNode *Position;
typedef Position BinTree;
struct TNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
}; 要求函数返回给定二叉树BT的高度值。 裁判测试程序样例： #include <stdio.h>
#include <stdlib.h>

typedef char ElementType;
typedef struct TNode *Position;
typedef Position BinTree;
struct TNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};

BinTree CreatBinTree(); /* 实现细节忽略 */
int GetHeight( BinTree BT );

int main()
{
    BinTree BT = CreatBinTree();
    printf("%d\n", GetHeight(BT));
    return 0;
}
/* 你的代码将被嵌在这里 */ 输出样例（对于图中给出的树）： 4
代码答案：
int GetHeight( BinTree BT )
{
    if(BT) 
    {
        if(GetHeight(BT->Left)>GetHeight(BT->Right))   
        return (1+GetHeight(BT->Left));
        else 
		return (1+GetHeight(BT->Right));
    }
    else 
	return 0;
}

题目141:
本题要求按照先序遍历的顺序输出给定二叉树的叶结点。 函数接口定义： void PreorderPrintLeaves( BinTree BT ); 其中BinTree结构定义如下： typedef struct TNode *Position;
typedef Position BinTree;
struct TNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
}; 函数PreorderPrintLeaves应按照先序遍历的顺序输出给定二叉树BT的叶结点，格式为一个空格跟着一个字符。 裁判测试程序样例： #include <stdio.h>
#include <stdlib.h>

typedef char ElementType;
typedef struct TNode *Position;
typedef Position BinTree;
struct TNode{
    ElementType Data;
    BinTree Left;
    BinTree Right;
};

BinTree CreatBinTree(); /* 实现细节忽略 */
void PreorderPrintLeaves( BinTree BT );

int main()
{
    BinTree BT = CreatBinTree();
    printf("Leaf nodes are:");
    PreorderPrintLeaves(BT);
    printf("\n");

    return 0;
}
/* 你的代码将被嵌在这里 */ 输出样例（对于图中给出的树）： Leaf nodes are: D E H I
代码答案：
void PreorderPrintLeaves(BinTree BT)
{
    if(BT==NULL)
    {
        return;
    }
    if(BT->Left==NULL&&BT->Right==NULL)
    printf(" %c",BT->Data);
    if(BT->Left)
    PreorderPrintLeaves(BT->Left);
    if(BT->Right)
    PreorderPrintLeaves(BT->Right);
}

题目142:
编程实现冒泡排序函数。void bubbleSort(int arr[], int n);。其中arr存放待排序的数据，n为数组长度（1≤n≤1000）。 函数接口定义如下： /* 对长度为n的数组arr执行冒泡排序 */
void bubbleSort(int arr[], int n); 请实现bubbleSort函数，使排序后的数据从小到大排列。 裁判测试程序样例： #include <stdio.h>

#define N 1000
int arr[N];

/* 对长度为n的数组arr执行冒泡排序 */
void bubbleSort(int arr[], int n);

/* 打印长度为n的数组arr */
void printArray(int arr[], int n);

void swap(int *xp, int *yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

int main() {
    int n, i;
    scanf("%d", &n);
    for (i = 0; i < n; ++i) {
        scanf("%d", &arr[i]);
    }
    bubbleSort(arr, n);
    printArray(arr, n);
    return 0;
}
/* 打印长度为n的数组arr */
void printArray(int arr[], int n) {
    int i;
    for (i = 0; i < n; i++) {
        printf("%d", arr[i]);
        if (i < n - 1)    /* 下标0..n-2每个元素后面有个空格 */
            printf(" ");   /*下标n-1,也就是最后一个元素后面没有空格*/
    }
    printf("\n");  /* 一行打印完后换行 */
}

/* 你的代码将嵌在这里 */ 输入样例： 10
1 19 9 11 4 3 5 8 10 6 输出样例： 1 3 4 5 6 8 9 10 11 19
代码答案：
void bubbleSort(int arr[],int n)
{
    int P,i;
    int flag;
    for(P=n-1;P>=0;P--)
    {
        flag=0;
        for(i=0;i<P;i++)
		{
            if(arr[i]>arr[i+1])
            {
                swap(&arr[i],&arr[i+1]);
                flag=1;
            }
        }
        if(flag==0) 
        break;
    }
}

题目143:
本题要求实现二分查找算法。 函数接口定义： Position BinarySearch( List L, ElementType X ); 其中List结构定义如下： typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
}; L是用户传入的一个线性表，其中ElementType元素可以通过 >>>、 ======、 <<<进行比较，并且题目保证传入的数据是递增有序的。函数BinarySearch要查找X在Data中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记NotFound。 裁判测试程序样例： #include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 10
#define NotFound 0
typedef int ElementType;

typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */
Position BinarySearch( List L, ElementType X );

int main()
{
    List L;
    ElementType X;
    Position P;

    L = ReadInput();
    scanf("%d", &X);
    P = BinarySearch( L, X );
    printf("%d\n", P);

    return 0;
}

/* 你的代码将被嵌在这里 */ 输入样例1： 5
12 31 55 89 101
31 输出样例1： 2 输入样例2： 3
26 78 233
31 输出样例2： 0 鸣谢宁波大学 Eyre-lemon-郎俊杰 同学修正原题！
代码答案：
Position BinarySearch( List L, ElementType X )
{
 int k;
 int high=L->Last;
 int low=1;
    while(low<=high)
    {
        k=(high+low)/2;
      if(X<L->Data[k])
     {
        high=k-1;
     } 
        else if(X>L->Data[k]){
           low=k+1;
        }
        else
        {
            return k;
        }
    }
  return NotFound;
}

题目144:
给定一系列正整数，请设计一个尽可能高效的算法，查找倒数第K个位置上的数字。 输入格式: 输入首先给出一个正整数K，随后是若干非负整数，最后以一个负整数表示结尾（该负数不算在序列内，不要处理）。 输出格式: 输出倒数第K个位置上的数据。如果这个位置不存在，输出错误信息NULL。 输入样例: 4 1 2 3 4 5 6 7 8 9 0 -1 输出样例: 7
代码答案：
#include<iostream>
#include<cstdlib>
#include<malloc.h>
using namespace std;
typedef struct LNode
{
    int data;
    struct LNode * next;
}LNode, *List;
int main()
{
    List L;
    L=(LNode*)malloc(sizeof(LNode));
    L->next=NULL;
    LNode *temp,*p=L;
    int data,k,len=0;
    cin>>k;
    while(cin>>data&&data!=EOF)
	{
        if(data<0)
        break;
        temp=(LNode *)malloc(sizeof(LNode));
        temp->next=NULL;
        temp->data=data;
        p->next=temp;
        p=temp;
        len++;
    }
    len=len-k+1;
    if(len<1)
    cout<<"NULL";
    else
	{
        p=L;
        while(len>0)
		{
            p=p->next;
            len--;
        }
        cout<<p->data;
    }
}

题目145:
我们已经知道了将 N个整数按从小到大排序的冒泡排序法。本题要求将此方法用于字符串序列，并对任意给定的 KKK（ <N<N<N），输出扫描完第 KKK遍后的中间结果序列。 输入格式： 输入在第1行中给出 NNN和 KKK（ 1≤K<N≤1001\le K<N\le 1001≤K<N≤100），此后 NNN行，每行包含一个长度不超过10的、仅由小写英文字母组成的非空字符串。 输出格式： 输出冒泡排序法扫描完第 KKK遍后的中间结果序列，每行包含一个字符串。 输入样例： 6 2
best
cat
east
a
free
day 输出样例： best
a
cat
day
east
free
代码答案：
#include<iostream>
using namespace std;
int main()
{
	int n,m;
	string str,a[101];
	int i,j;
	cin>>n>>m;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
	} 
	for(i=0;i<m;i++)
	{
		for(j=0;j<n-i-1;j++)
		{
			if(a[j]>a[j+1])
			{
				str=a[j];
				a[j]=a[j+1];
				a[j+1]=str;
			}
		}
	}
	for(i=0;i<n;i++)
	cout<<a[i]<<endl;
}

题目146:
利用二分查找找出所给出的数在数组中的下标 输入格式: 第一行输入n和m表示数组有n个数据，m表示要对m个数进行查找 输出格式: 所有输出在一行完成，行末没有多余空格和多余回车。 输入样例: 5 5
1 2 3 4 5
1 2 3 4 5```

### 输出样例:
```out
0 1 2 3 4
代码答案：
#include <iostream>
using namespace std;
int num[1000005];
int binarySearch(int begin,int end,int target) {
	while(begin<end) {
		int mid = (begin + end) / 2;
		if(num[mid]==target)
			return mid;
		else if(num[mid]<target)
			begin = mid + 1;
		else
			end = mid - 1;
	}
	return end;
}

int main() {
	int a,b;
	int x;
	scanf("%d %d",&a,&b);
	for(int i = 0; i<a; i++)
		scanf("%d",&num[i]);
	for(int i = 0; i<b; i++) {
		scanf("%d",&x);
		if(i>0)
			printf(" ");
		printf("%d",binarySearch(0,a-1,x));
	}
	return 0;
}

题目147:
请编写程序检查C语言源程序中下列符号是否配对：/*与*/、(与)、[与]、{与}。 输入格式: 输入为一个C语言源程序。当读到某一行中只有一个句点.和一个回车的时候，标志着输入结束。程序中需要检查配对的符号不超过100个。 输出格式: 首先，如果所有符号配对正确，则在第一行中输出YES，否则输出NO。然后在第二行中指出第一个不配对的符号：如果缺少左符号，则输出?-右符号；如果缺少右符号，则输出左符号-?。 输入样例1： void test()
{
    int i, A[10];
    for (i=0; i<10; i++) /*/
        A[i] = i;
}
.
 输出样例1： NO
/*-? 输入样例2： void test()
{
    int i, A[10];
    for (i=0; i<10; i++) /**/
        A[i] = i;
}]
.
 输出样例2： NO
?-] 输入样例3： void test()
{
    int i
    double A[10];
    for (i=0; i<10; i++) /**/
        A[i] = 0.1*i;
}
.
 输出样例3： YES
代码答案：
#include <iostream>  
#include <cstdio>  
#include <cstring>  
#include <algorithm>  
#include <stack>  
using namespace std;  
void print(char ch) {  
    if(ch == '(') printf("(-?\n");  
    else if(ch == '[') printf("[-?\n");  
    else if(ch == '{') printf("{-?\n");  
    else if(ch == '<') printf("/*-?\n");  
}  
int main() {  
    char str[1000];  
    stack <char> s;   
    int flag = 1;  
    while(1){  
      scanf("%s",str);
     //   gets(str);  
        if(str[0] == '.' && str[1] == 0) break;  
        int i;  
        for(i = 0; str[i]; i++) {  
            if(flag == 0) break;     
            if(str[i] == '(' || str[i] == '[' || str[i] == '{') {  
                s.push(str[i]);  
            }  
            else if(str[i] == '/' && str[i + 1] == '*') {  
                s.push('<');  
                i++;  
            }  
            else if(str[i] == ')') {  
                if(!s.empty() && s.top() == '(') s.pop();  
                else {  
                    printf("NO\n");  
                    flag = 0;  
                    if(s.empty()) {  
                        printf("?-)\n");  
                    }  
                    else {  
                        print(s.top());  
                    }  
                    break;  
                }  
            }  
            else if(str[i] == ']') {  
                if(!s.empty() && s.top() == '[') s.pop();  
                else {  
                    printf("NO\n");  
                    flag = 0;  
                    if(s.empty()) {  
                        printf("?-]\n");  
                    }  
                    else {  
                        print(s.top());  
                    }  
                    break;  
                }  
            }  
            else if(str[i] == '}') {  
                if(!s.empty() && s.top() == '{') s.pop();  
                else {  
                    printf("NO\n");  
                    flag = 0;  
                    if(s.empty()) {  
                        printf("?-}\n");  
                    }  
                    else {  
                        print(s.top());  
                    }  
                    break;  
                }  
            }  
            else if(str[i] == '*' && str[i + 1] == '/') {  
                i++;   
                if(!s.empty() && s.top() == '<') s.pop();  
                else {  
                    printf("NO\n");  
                    flag = 0;  
                    if(s.empty()) {  
                        printf("?-*/\n");  
                    }  
                    else {  
                        print(s.top());  
                    }  
                    break;  
                }  
            }  
        }  
    }  
    if(flag && s.empty()) printf("YES\n");  
    else if(flag) {  
        printf("NO\n"); 
        print(s.top());  
    }  
    return 0;  
}




//树和图 
题目0:
Prim 算法是维护一个森林，每一步把两棵树合并成一棵。
选项： T F
答案：F




题目1:
Kruskal 算法是维护一个森林，每一步把两棵树合并成一棵。
选项： T F
答案：T




题目2:
Kruskal 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。
选项： T F
答案：F




题目3:
Prim 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。
选项： T F
答案：T




题目4:
对于带权无向图 G = (V, E)，M 是 G 的最小生成树，则 M 中任意两点 V1 到 V2 的路径一定是它们之间的最短路径。
选项： T F
答案：F




题目5:
在一个有权无向图中，若b到a的最短路径距离是12，且c到b之间存在一条权为2的边，则c到a的最短路径距离一定不小于10。
选项： T F
答案：T




题目6:
给定一个有向图的邻接表如下图，则该图有__个强连通分量。
选项： A. 4 {{0, 1, 5}, {2}, {3}, {4}} B. 3 {{2}, {4}, {0, 1, 3, 5}} C. 1 {0, 1, 2, 3, 4, 5} D. 1 {0, 5, 1, 3}
答案：B. 3 {{2}, {4}, {0, 1, 3, 5}}




题目7:
下列选项中，不是下图深度优先搜索序列的是：
选项： A. V1V_1V1, V5V_5V5, V4V_4V4, V3V_3V3, V2V_2V2 B. V1V_1V1, V3V_3V3, V2V_2V2, V5V_5V5, V4V_4V4 C. V1V_1V1, V2V_2V2, V5V_5V5, V4V_4V4, V3V_3V3 D. V1V_1V1, V2V_2V2, V3V_3V3, V4V_4V4, V5V_5V5
答案：D. V1V_1V1, V2V_2V2, V3V_3V3, V4V_4V4, V5V_5V5




题目8:
给定有向图的邻接矩阵如下： 顶点2（编号从0开始）的出度和入度分别是：
选项： A. 3, 1 B. 1, 3 C. 0, 2 D. 2, 0
答案：C. 0, 2




题目9:
若某图的深度优先搜索序列是{V1, V4, V0, V3, V2}，则下列哪个图不可能对应该序列？
选项： A. B. C. D.
答案：C.




题目10:
若某图的深度优先搜索序列是{V2, V0, V4, V3, V1}，则下列哪个图不可能对应该序列？
选项： A. B. C. D.
答案：D.




题目11:
给定一有向图的邻接表如下。从顶点V1出发按深度优先搜索法进行遍历，则得到的一种顶点序列为：
选项： A. V1,V2,V3,V4,V7,V6,V5 B. V1,V5,V4,V7,V6,V2,V3 C. V1,V5,V6,V4,V7,V2,V3 D. V1,V5,V4,V7,V6,V3,V2
答案：D. V1,V5,V4,V7,V6,V3,V2




题目12:
下面给出的有向图中，各个顶点的入度和出度分别是：
选项： A. 入度: 0, 2, 3, 1, 2; 出度: 3, 2, 1, 1, 1 B. 入度: 3, 2, 1, 1, 1; 出度: 0, 2, 3, 1, 2 C. 入度: 3, 4, 4, 2, 3; 出度: 3, 4, 4, 2, 3 D. 入度: 0, 1, 2, 1, 1; 出度: 3, 2, 1, 1, 1
答案：A. 入度: 0, 2, 3, 1, 2; 出度: 3, 2, 1, 1, 1




题目13:
如果G是一个有15条边的非连通无向图，那么该图顶点个数最少为多少？
选项： A. 7 B. 8 C. 9 D. 10
答案：A. 7




题目14:
图的广度优先遍历类似于二叉树的：
选项： A. 先序遍历 B. 中序遍历 C. 层次遍历 D. 后序遍历
答案：C. 层次遍历




题目15:
下面给出的有向图中，有__个强连通分量。
选项： A. 1 ({0,1,2,3,4}) B. 1 ({1,2,3,4}) C. 2 ({1,2,3,4}, {0}) D. 5 ({0}, {1}, {2}, {3}, {4})
答案：C. 2 ({1,2,3,4}, {0})




题目16:
如果从无向图的任一顶点出发进行一次深度优先搜索可访问所有顶点，则该图一定是：
选项： A. 连通图 B. 完全图 C. 有回路的图 D. 一棵树
答案：A. 连通图




题目17:
在图中自c点开始进行广度优先遍历算法可能得到的结果为：
选项： A. c,a,b,e,f,d B. c,a,f,d,e,b C. c,f,a,d,e,b D. c,f,a,b,d,e
答案：C. c,f,a,d,e,b




题目18:
如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则下列说法中不正确的是：
选项： A. G肯定不是完全图 B. G中一定有回路 C. G一定不是连通图 D. G有2个连通分量
答案：B. G中一定有回路




题目19:
给定一有向图的邻接表如下。从顶点V1出发按广度优先搜索法进行遍历，则得到的一种顶点序列为：
选项： A. V1,V2,V3,V4,V5 B. V1,V2,V3,V5,V4 C. V1,V3,V2,V4,V5 D. V1,V4,V3,V5,V2
答案：C. V1,V3,V2,V4,V5




题目20:
已知一个图的邻接矩阵如下，则从顶点V1出发按广度优先搜索法进行遍历，可能得到的一种顶点序列为：
选项： A. V1,V2,V3,V5,V4,V6 B. V1,V2,V4,V5,V6,V3 C. V1,V3,V5,V2,V4,V6 D. V1,V3,V5,V6,V4,V2
答案：A. V1,V2,V3,V5,V4,V6




题目21:
具有5个顶点的有向完全图有多少条弧？
选项： A. 10 B. 16 C. 20 D. 25
答案：C. 20




题目22:
对于一个具有 NNN个顶点的无向图，要连通所有顶点至少需要多少条边？
选项： A. N?1N-1N?1 B. NNN C. N+1N+1N+1 D. N/2N/2N/2
答案：A. N?1N-1N?1




题目23:
具有 NNN（ N>0N>0N>0）个顶点的无向图至少有多少个连通分量？
选项： A. 0 B. 1 C. N?1N-1N?1 D. NNN
答案：B. 1




题目24:
具有 NNN（ N>0N>0N>0）个顶点的无向图至多有多少个连通分量？
选项： A. 0 B. 1 C. N?1N-1N?1 D. NNN
答案：D. NNN




题目25:
一个有 NNN个顶点的强连通图至少有多少条边？
选项： A. N?1N-1N?1 B. NNN C. N+1N+1N+1 D. N(N?1)N(N-1)N(N?1)
答案：B. NNN




题目26:
对于一个具有 NNN个顶点的无向图，若采用邻接矩阵表示，则该矩阵的大小是：
选项： A. N?1N-1N?1 B. NNN C. (N?1)2(N-1)^2(N?1)2 D. N2N^2N2
答案：D. N2N^2N2




题目27:
若一个有向图用邻接矩阵表示，则第 iii个结点的入度就是：
选项： A. 第 iii行的元素个数 B. 第 iii行的非零元素个数 C. 第 iii列的非零元素个数 D. 第 iii列的零元素个数
答案：C. 第 iii列的非零元素个数




题目28:
下面关于图的存储的叙述中，哪一个是正确的？
选项： A. 用相邻矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关 B. 用相邻矩阵法存储图，占用的存储空间数只与图中边数有关，而与结点个数无关 C. 用邻接表法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关 D. 用邻接表法存储图，占用的存储空间数只与图中边数有关，而与结点个数无关
答案：A. 用相邻矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关




题目29:
关于图的邻接矩阵，下列哪个结论是正确的？
选项： A. 有向图的邻接矩阵总是不对称的 B. 有向图的邻接矩阵可以是对称的，也可以是不对称的 C. 无向图的邻接矩阵总是不对称的 D. 无向图的邻接矩阵可以是不对称的，也可以是对称的
答案：B. 有向图的邻接矩阵可以是对称的，也可以是不对称的




题目30:
在一个无向图中，所有顶点的度数之和等于所有边数的多少倍？
选项： A. 1/2 B. 1 C. 2 D. 4
答案：C. 2




题目31:
在任一有向图中，所有顶点的入度之和与所有顶点的出度之和的关系是：
选项： A. 相等 B. 大于等于 C. 小于等于 D. 不确定
答案：A. 相等




题目32:
设无向图的顶点个数为 NNN，则该图最多有多少条边？
选项： A. N?1N-1N?1 B. N(N?1)/2N(N-1)/2N(N?1)/2 C. N(N+1)/2N(N+1)/2N(N+1)/2 D. N2N^2N2
答案：B. N(N?1)/2N(N-1)/2N(N?1)/2




题目33:
下列说法不正确的是：
选项： A. 图的遍历是从给定的源点出发每一个顶点仅被访问一次 B. 遍历的基本算法有两种：深度遍历和广度遍历 C. 图的深度遍历是一个递归过程 D. 图的深度遍历不适用于有向图
答案：D. 图的深度遍历不适用于有向图




题目34:
图的深度优先遍历类似于二叉树的：
选项： A. 先序遍历 B. 中序遍历 C. 后序遍历 D. 层次遍历
答案：A. 先序遍历




题目35:
给定无向图G，从V0出发进行深度优先遍历访问的边集合为： {(V0,V1), (V0,V4), (V1,V2), (V1,V3), (V4,V5), (V5,V6)}。则下面哪条边不可能出现在G中？
选项： A. (V0,V2) B. (V0,V6) C. (V1,V5) D. (V4,V6)
答案：C. (V1,V5)




题目36:
任何一个带权无向连通图的最小生成树――
选项： A. 是唯一的 B. 是不唯一的 C. 有可能不唯一 D. 有可能不存在
答案：C. 有可能不唯一




题目37:
给定有权无向图的邻接矩阵如下，其最小生成树的总权重是：
选项： A. 10 B. 11 C. 12 D. 14
答案：D. 14




题目38:
给定有权无向图的邻接矩阵如下，其最小生成树的总权重是：
选项： A. 24 B. 23 C. 18 D. 17
答案：B. 23




题目39:
给定有权无向图如下。关于其最小生成树，下列哪句是对的？
选项： A. 边(B, A)一定在树中，树的总权重为23 B. 边(D, C)一定在树中，树的总权重为20 C. 最小生成树不唯一，其总权重为23 D. 最小生成树唯一，其总权重为20
答案：C. 最小生成树不唯一，其总权重为23




题目40:
在一个有权无向图中，如果顶点b到顶点a的最短路径长度是10，顶点c与顶点b之间存在一条长度为3的边。那么下列说法中有几句是正确的？ c与a的最短路径长度就是13 c与a的最短路径长度就是7 c与a的最短路径长度不超过13 c与a的最短路径不小于7
选项： A. 1句 B. 2句 C. 3句 D. 4句
答案：B. 2句




题目41:
我们用一个有向图来表示航空公司所有航班的航线。下列哪种算法最适合解决找给定两城市间最经济的飞行路线问题？
选项： A. Dijkstra算法 B. Kruskal算法 C. 深度优先搜索 D. 拓扑排序算法
答案：A. Dijkstra算法




题目42:
使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是：
选项： A. 6, 7, 5, 3, 2, 4 B. 6, 2, 5, 7, 3, 4 C. 2, 3, 4, 5, 6, 7 D. 2, 4, 3, 6, 5, 7
答案：A. 6, 7, 5, 3, 2, 4




题目0:
存在一棵总共有2016个结点的二叉树，其中有16个结点只有一个孩子。
选项： T F
答案：F




题目1:
二叉树通常有顺序存储结构和链式存储结构。
选项： T F
答案：T




题目2:
设只包含根结点的二叉树高度为0，则高度为k的二叉树最小结点数为k+1。
选项： T F
答案：T




题目3:
具有10个叶结点的二叉树中，有9个度为2的结点。
选项： T F
答案：T




题目4:
完全二叉树中，若一个结点没有左孩子，则它必是树叶。
选项： T F
答案：T




题目5:
任何二叉搜索树中同一层的结点从左到右是有序的（从小到大）。
选项： T F
答案：T




题目6:
在一棵二叉搜索树上查找63，序列39、101、25、80、70、59、63是一种可能的查找时的结点值比较序列。
选项： T F
答案：F




题目7:
在一棵由包含4、5、6等等一系列整数结点构成的二叉搜索树中，如果结点4和6在树的同一层，那么可以断定结点5一定是结点4和6的父亲结点。
选项： T F
答案：F




题目8:
二叉排序树的后序遍历序列必然是递增的。
选项： T F
答案：F




题目9:
对一棵二叉排序树按前序方法遍历得出的结点序列是从小到大的序列。
选项： T F
答案：F




题目10:
对一棵满二叉树，m个树叶，n个结点，深度为h，则（）。
选项： A. n=h+m B. h+m=2n C. m=h-1 D. n= 2h2^h2h-1
答案：D. n= 2h2^h2h-1




题目11:
深度为4的满二叉树的结点数为（）。
选项： A. 7 B. 15 C. 16 D. 31
答案：B. 15




题目12:
有关树和二叉树的叙述错误的是（）。
选项： A. 树中的最大度数没有限制，而二叉树结点的最大度数为2； B. 树的结点无左右之分，而二叉树的结点有左右之分； C. 树的每个结点的孩子数为0到多个, 而二叉树每个结点均有两个孩子； D. 树和二叉树均为树形结构
答案：C. 树的每个结点的孩子数为0到多个, 而二叉树每个结点均有两个孩子；




题目13:
按照二叉树定义，具有3个结点的二叉树共有（）种形态。
选项： A. 3 B. 4 C. 5 D. 6
答案：C. 5




题目14:
一个具有1025个结点的二叉树的高h为（）。
选项： A. 10 B. 11 C. 11～1025 D. 10～1024
答案：C. 11～1025




题目15:
在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是：
选项： A. 41 B. 82 C. 113 D. 122
答案：B. 82




题目16:
在有n个结点的二叉树的二叉链表表示中，空指针数（）。
选项： A. 不定 B. n+1 C. n D. n-1
答案：B. n+1




题目17:
一棵二叉树中，双分支结点数为15，单分支结点数为30，则叶子结点数为（）个。
选项： A. 15 B. 16 C. 17 D. 47
答案：B. 16




题目18:
要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是：
选项： A. 只有左子树 B. 只有右子树 C. 结点的度均为1 D. 结点的度均为2
答案：B. 只有右子树




题目19:
已知一棵二叉树的树形如下图所示，其后序序列为{ e, a, c, b, d, g, f }。树中与结点a同层的结点是：
选项： A. c B. d C. f D. g
答案：B. d




题目20:
若一棵二叉树的前序遍历序列是{ 4, 2, 1, 3, 6, 5, 7 }，中序遍历序列是{ 1, 2, 3, 4, 5, 6, 7 }，则下列哪句是错的？
选项： A. 这是一棵完全二叉树 B. 所有的奇数都在叶子结点上 C. 这是一棵二叉搜索树 D. 2是5的父结点
答案：D. 2是5的父结点




题目21:
二叉树的中序遍历也可以循环地完成。给定循环中堆栈的操作序列如下（其中push为入栈，pop为出栈）： push(1), push(2), push(3), pop(), push(4), pop(), pop(), push(5), pop(), pop(), push(6), pop() 以下哪句是对的？
选项： A. 6是根结点 B. 3和5是兄弟结点 C. 2是4的父结点 D. 以上全不对
答案：B. 3和5是兄弟结点




题目22:
如果二叉树的前序遍历结果是12345，后序遍历结果是32541，那么该二叉树的中序遍历结果是什么？
选项： A. 23145 B. 23154 C. 24135 D. 无法确定
答案：D. 无法确定




题目23:
在下述结论中，正确的是： ①只有一个结点的二叉树的度为0; ②二叉树的度为2； ③二叉树的左右子树可任意交换； ④深度为K的完全二叉树的结点个数小于或等于深度相同的满二叉树。
选项： A. ①④ B. ②④ C. ①②③ D. ②③④
答案：A. ①④




题目24:
二叉树中第5层（根的层号为1）上的结点个数最多为：
选项： A. 8 B. 15 C. 16 D. 32
答案：C. 16




题目25:
先序遍历图示二叉树的结果为
选项： A. A，B，C，D，H，E，I，F，G B. A，B，D，H，I，E，C，F，G C. H，D，I，B，E，A，F，C，G D. H，I，D，B，E，F，G，A，C
答案：B. A，B，D，H，I，E，C，F，G




题目26:
某二叉树的前序和后序遍历序列正好相反，则该二叉树一定是
选项： A. 空或只有一个结点 B. 高度等于其结点数 C. 任一结点无左孩子 D. 任一结点无右孩子
答案：B. 高度等于其结点数




题目27:
已知一棵二叉树的先序遍历结果是ABC，则以下哪个序列是不可能的中序遍历结果：
选项： A. ABC B. BAC C. CBA D. CAB
答案：D. CAB




题目28:
假定一棵三叉树的结点数为50，则它的最小高度为（）。
选项： A. 3 B. 4 C. 5 D. 6
答案：C. 5




题目29:
如果二叉树的后序遍历结果是FDEBGCA，中序遍历结果是FDBEACG，那么该二叉树的前序遍历结果是什么？
选项： A. ABCDEFG B. ABDFEGC C. ABDFECG D. ABDEFCG
答案：C. ABDFECG




题目30:
一棵有1001个结点的完全二叉树有多少个叶子结点?
选项： A. 250 B. 254 C. 500 D. 501
答案：D. 501




题目31:
在含有27个结点的二叉搜索树上，查找关键字为35的结点，则被依次比较的关键字有可能是（）。
选项： A. 46,36,18,28,35 B. 46,28,18,36,35 C. 28,36,18,46,35 D. 18,36,28,46,35
答案：A. 46,36,18,28,35




题目32:
若二叉搜索树是有 NNN个结点的完全二叉树，则不正确的说法是：
选项： A. 所有结点的平均查找效率是 O(logN)O(logN)O(logN) B. 最小值一定在叶结点上 C. 最大值一定在叶结点上 D. 中位值结点在根结点或根的左子树上
答案：C. 最大值一定在叶结点上




题目33:
将{ 32, 2, 15, 65, 28, 10 }依次插入初始为空的二叉搜索树。则该树的前序遍历结果是：
选项： A. 2, 10, 15, 28, 32, 65 B. 32, 2, 10, 15, 28, 65 C. 10, 28, 15, 2, 65, 32 D. 32, 2, 15, 10, 28, 65
答案：D. 32, 2, 15, 10, 28, 65




题目34:
已知8个数据元素为（34，76，45，18，26，54，92，65），按照依次插入结点的方法生成一棵二叉搜索树后，最后两层上的结点总数为：
选项： A. 1 B. 2 C. 3 D. 4
答案：B. 2




题目35:
若一棵二叉树的前序遍历序列是{ 4, 2, 1, 3, 6, 5, 7 }，中序遍历序列是{ 1, 2, 3, 4, 5, 6, 7 }，则下列哪句是错的？
选项： A. 这是一棵完全二叉树 B. 4是3的父结点 C. 所有的奇数都在叶子结点上 D. 这是一棵二叉搜索树
答案：B. 4是3的父结点




题目36:
对二叉搜索树进行什么遍历可以得到从小到大的排序序列？
选项： A. 前序遍历 B. 后序遍历 C. 中序遍历 D. 层次遍历
答案：C. 中序遍历




题目37:
若二叉搜索树是有 NNN个结点的完全二叉树，则不正确的说法是：
选项： A. 平均查找效率是 O(logN)O(logN)O(logN) B. 最大值一定在最后一层 C. 最小值一定在叶结点上 D. 中位值结点在根结点或根的左子树上
答案：B. 最大值一定在最后一层




题目38:
将{5, 2, 7, 3, 4, 1, 6}依次插入初始为空的二叉搜索树。则该树的后序遍历结果是：
选项： A. 1, 2, 3, 4, 6, 7, 5 B. 1, 4, 2, 6, 3, 7, 5 C. 1, 4, 3, 2, 6, 7, 5 D. 5, 4, 3, 7, 6, 2, 1
答案：C. 1, 4, 3, 2, 6, 7, 5




题目39:
已知二叉排序树如下图所示，元素之间应满足的大小关系是：
选项： A. x1<x2<x5x_1 < x_2 < x_5x1<x2<x5 B. x1<x4<x5x_1 < x_4 < x_5x1<x4<x5 C. x3<x5<x4x_3 < x_5 < x_4x3<x5<x4 D. x4<x3<x5x_4 < x_3 < x_5x4<x3<x5
答案：C. x3<x5<x4x_3 < x_5 < x_4x3<x5<x4




题目40:
在有 NNN个结点且为完全二叉树的二叉搜索树中查找一个键值，其平均比较次数的数量级为：
选项： A. O(logN)O(logN)O(logN) B. O(N)O(N)O(N) C. O(NlogN)O(NlogN)O(NlogN) D. O(N2)O(N^2)O(N2)
答案：A. O(logN)O(logN)O(logN)




题目41:
已知字符集{ a, b, c, d, e, f, g, h }。若各字符的哈夫曼编码依次是 0100, 10, 0000, 0101, 001, 011, 11, 0001，则编码序列 0100011001001011110101 的译码结果是：
选项： A. acgabfh B. adbagbb C. afbeagd D. afeefgd
答案：D. afeefgd




题目42:
用线性时间复杂度的算法将给定序列{ 28, 12, 5, 8, 19, 20, 15, 22 }调整为最大堆（大根堆），然后插入30。则结果序列为：
选项： A. { 5, 8, 28, 12, 19, 20, 15, 22, 30 } B. { 30, 28, 20, 22, 12, 5, 15, 8, 19 } C. { 30, 28, 22, 20, 19, 15, 12, 8, 5 } D. { 30, 28, 20, 22, 19, 5, 15, 8, 12 }
答案：D. { 30, 28, 20, 22, 19, 5, 15, 8, 12 }




题目43:
用线性时间复杂度的算法将给定序列{15, 26, 32, 8, 7, 20, 12, 13, 5, 19}调整为最小堆（小根堆），然后插入6。下列句子中错误的是：
选项： A. 5是根 B. 从根到26的路径是{5, 6, 8, 26} C. 32是12的左孩子 D. 7是19和15的父结点
答案：C. 32是12的左孩子




题目44:
对最小堆（小顶堆）{1,3,2,6,7,5,4,15,14,12,9,10,11,13,8} 进行三次删除最小元的操作后，结果序列为：
选项： A. 4,5,6,7,8,9,10,11,12,13,14,15 B. 4,6,5,13,7,10,8,15,14,12,9,11 C. 4,6,5,12,7,10,8,15,14,9,13,11 D. 4,5,6,12,7,10,8,15,14,13,9,11
答案：B. 4,6,5,13,7,10,8,15,14,12,9,11




题目45:
对 NNN（ N≥2N\ge 2N≥2）个权值均不相同的字符构造哈夫曼树。下列关于该哈夫曼树的叙述中，错误的是：
选项： A. 树中一定没有度为1的结点 B. 树中两个权值最小的结点一定是兄弟结点 C. 树中任一非叶结点的权值一定不小于下一层任一结点的权值 D. 该树一定是一棵完全二叉树
答案：D. 该树一定是一棵完全二叉树




题目46:
设一段文本中包含字符{a, b, c, d, e}，其出现频率相应为{3, 2, 5, 1, 1}。则经过哈夫曼编码后，文本所占字节数为：
选项： A. 40 B. 36 C. 25 D. 12
答案：C. 25




题目47:
由分别带权为9、2、5、7的四个叶子结点构成一棵哈夫曼树，该树的带权路径长度为：
选项： A. 23 B. 37 C. 44 D. 46
答案：C. 44




题目48:
将数字 {10, 12, 1, 14, 6, 5, 8, 15, 3, 9, 7, 4, 11, 13, 2} 逐一插入一个初始为空的最小堆（小顶堆），得到的堆序列为：
选项： A. 1,3,2,12,6,4,8,15,14,9,7,5,11,13,10 B. 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 C. 1,2,3,6,7,5,4,15,14,12,9,10,11,13,8 D. 1,3,2,6,7,5,4,15,14,12,9,10,11,13,8
答案：D. 1,3,2,6,7,5,4,15,14,12,9,10,11,13,8




题目49:
本题要求实现二叉排序树的查找操作。 对于二叉排序树，如下图： 输入样例： 4
1 8 0 9 输出样例： 1 is found
8 is found
0 is not found
9 is not found 其中BSTree结构定义如下： typedef int ElemType;
typedef struct BSTNode
{
    ElemType data;
    struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree; 程序如下：
#include <stdio.h>
#include <stdlib.h>
typedef int ElemType;
typedef struct BSTNode
{
    ElemType data;
    struct BSTNode  *lchild,*rchild;
}BSTNode,*BSTree;
BSTree CreateBST();/ *二叉排序树创建，由裁判实现，细节不表* /
BSTree SearchBST(BSTree T,ElemType e);
int main()
{
    BSTree T,result;
    ElemType n,e;
    T = CreateBST();
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",&e);
        result = SearchBST(T,e);
        if(result) printf("%d is found\n",result->data);
        else printf("%d is not found\n",e);
    }
    return 0;
}
BSTree SearchBST(BSTree T,ElemType e)
{
    if((2分)) return T;
    if(e<T->data) return (2分);
    else (2分);
}
代码答案：




题目：1$$2^N$和$N^N$具有相同的增长速度。
 答案：FALSE

题目：2算法分析的两个主要方面是时间复杂度和空间复杂度的分析。
 答案：TRUE

题目：3算法可以没有输入，但是必须有输出。   答案：TRUE

题目：4数据元素是数据的最小单位。   答案：FALSE

题目：5数据的逻辑结构是指数据的各数据项之间的逻辑关系。   答案：FALSE

题目：6数据结构概念包括数据之间的逻辑结构、数据在计算机中的存储方式和数据的运算三个方面。   答案：TRUE

题目：7数据元素可以由类型互不相同的数据项构成。   答案：TRUE

题目：8数据的逻辑结构说明数据元素之间的顺序关系，它依赖于计算机的存储结构。    答案：FALSE

题目：9$$n! is $O(n^n).
 答案：FALSE

题目：10$$O(N^2) is the same as $O(1+2+3+\cdots+N).   答案：TRUE

题目：11对于顺序存储的长度为$N$的线性表，访问结点和增加结点的时间复杂度分别对应为$O(1)和$O(N)。
 答案：TRUE

题目：12若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存储最节省时间。
 答案：TRUE

题目：13对于顺序存储的长度为$N$的线性表，删除第一个元素和插入最后一个元素的时间复杂度分别对应为$O(1)和$O(N)。
 答案：TRUE

题目：14(neuDS)在顺序表中逻辑上相邻的元素，其对应的物理位置也是相邻的。   答案：FALSE

题目：15(neuDS)所谓随机存取，就是通过首地址和元素的位序号值可以在O(1)的时间内找到指定的元素。   答案：TRUE

题目：16(neuDS)顺序存储的线性表不支持随机存取。   答案：FALSE

题目：17(neuDS)在顺序表上进行插入、删除操作时需要移动元素的个数与待插入或待删除元素的位置无关。   答案：FALSE

题目：18(neuDS)顺序存储方式只能用于存储线性结构。   答案：FALSE

题目：19在具有$N$个结点的单链表中，访问结点和增加结点的时间复杂度分别对应为$O(1)和$O(N)。
 答案：FALSE

题目：20若用链表来表示一个线性表，则表中元素的地址一定是连续的。
 答案：FALSE

题目：21将$N$个数据按照从小到大顺序组织存放在一个单向链表中。如果采用二分查找，那么查找的平均时间复杂度是$O(logN)。
 答案：FALSE

题目：22取线性表的第i个元素的时间同i的大小有关。   答案：FALSE

题目：23链表的每个结点都恰好有一个指针。   答案：TRUE

题目：24线性表的顺序存储表示优于链式存储表示。   答案：FALSE

题目：25链式存储的优点是插入、删除元素时不会引起后续元素的移动，缺点是只能顺序访问各元素。   答案：TRUE

题目：26链表 - 存储结构

链表中逻辑上相邻的元素，其物理位置也一定相邻。
 答案：FALSE

题目：27通过对堆栈S操作：Push(S,1), Push(S,2), Pop(S), Push(S,3), Pop(S), Pop(S)。输出的序列为：123。
 答案：FALSE

题目：28若一个栈的输入序列为1，2，3，…，$N$，输出序列的第一个元素是$i$，则第$j$个输出元素是$j-i-1$。
 答案：FALSE

题目：29若一个栈的输入序列为{1, 2, 3, 4, 5}，则不可能得到{3, 4, 1, 2, 5}这样的出栈序列。
 答案：TRUE

题目：30栈和队列的存储方式，既可以是顺序方式，也可以是链式方式。   答案：TRUE

题目：31栈底元素是不能删除的元素。  答案：FALSE

题目：32顺序栈中元素值的大小是有序的。   答案：FALSE

题目：33在n个元素连续进栈以后，它们的出栈顺序和进栈顺序一定正好相反。   答案：TRUE

题目：34栈顶元素和栈底元素有可能是找桓鲈素。   答案：TRUE


------------------------------------------
题目1:下面程序段的时间复杂度是 (      )
```
i ＝ 0；
while（i<=n）
     i = i * 3；
```  choices=["O(2n)"  "O(n)"  "O(n$^2$)"  "O($log_3n$)"]   答案：D

题目2:下面程序段的时间复杂度是(       )。
```
for( i =0; i<n; i++)
   for(j=0;j<m;j++)
 	  A[i][j] ＝ 0;
```  choices=["O(2n)"  "O(n*m)"  "O($n^2$)"  "O(logn)"]   答案：D

题目3:程序段
```
FOR  i:=n-1  DOWNTO  1  DO
            FOR j:=1 TO i DO
               IF A[j]>A[j+1]
                  THEN  A[j]与A[j+1]对换；
```
其中 n为正整数，则最后一行的语句频度在最坏情况下是（   ）  choices=["O（n）"  "O(nlogn)"  "O($n^3$)"  "O($n^2$)"]   答案：D

题目4:下列函数中，哪个函数具有最快的增长速度？  choices=["$N^2 logN$"  "$N(logN)^4$"  "$N^3$"  "$NlogN^2$"]   答案：D

题目5:下面代码段的时间复杂度是（）。
```c++
x=n; //n>1
y=0;
while( x≥(y+1)*(y+1) )
    y++;
```  choices=["$O(1)"  "$O(n^{1/2})"  "$O(n)"  "$O(log_2 n)"]   答案：D

题目6:在数据结构中，从逻辑上可以把数据结构分成（   ）。  choices=["动态结构和静态结构"  "紧凑结构和非紧凑结构"  "线性结构和非线性结构"  "内部结构和外部结构"]   答案：C

题目7:与数据元素本身的形式、内容、相对位置、个数无关的是数据的（   ）。  choices=["存储结构"  "存储实现"  "逻辑结构"  "运算实现"]   答案：C

题目8:通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（   ）。  choices=["数据在同一范围内取值"  "不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致"  "每个数据元素都一样"  "数据元素所包含的数据项的个数要相等"]   答案：B

题目9:以下说法正确的是（   ）。  choices=["数据元素是数据的最小单位"  "数据项是数据的基本单位"  "数据结构是带有结构的各数据项的集合"  "一些表面上很不相同的数据可以有相同的逻辑结构"]   答案：D

题目10:下列哪个函数是$O(N)的？  choices=["$2NlogN$"  "$logN^2$"  "$N(logN)^2$"  "$N^2/2$"]   答案：B

题目11:算法的时间复杂度取决于（    ）。  choices=["问题的规模"  "待处理数据的初态"  "计算机的配置"  "A和B"]   答案：A

题目12:下面代码段的时间复杂度是（）。
```c++
s=0;
for ( i=0; i<n; i++ )
    for( j=0; j<n; j++ )
        s+=B[i][j];
sum=s;
```  choices=["$O(1)"  "$O(log_2 n)"  "$O(n)"  "$O(n^2)"]   答案：D

题目13:给定$N\times N\times N$的三维数组A，则在不改变数组的前提下，查找最小元素的时间复杂度是：  choices=["$O(N^2)"  "$O(NlogN)"  "$O(N^3 logN)"  "$O(N^3)"]   答案：D

题目14:以下数据结构中，（  ）是非线性数据结构。  choices=["树"  "字符串"  "队列"  "栈"]   答案：A

题目15:下列代码
```
if ( A > B ) {
    for ( i=0; i<N; i++ )
        for ( j=N*N; j>i; j-- )
            A += B;
}
else {
    for ( i=0; i<N*2; i++ )
        for ( j=N*2; j>i; j-- )
            A += B;
}
```
的时间复杂度是：  choices=["$O(N)"  "$O(N^2)"  "$O(N^3)"  "$O(N^4)"]   答案：D

题目16:数组A[1..5,1..6]每个元素占5个单元，将其按行优先次序存储在起始地址为1000的连续的内存单元中，则元素A[5,5]的地址为：  choices=["1120"  "1125"  "1140"  "1145"]   答案：C

题目17:在$N$个结点的顺序表中，算法的时间复杂度为O(1)的操作是：  choices=["访问第$i$个结点（$1\\le i\\le N$）和求第$i$个结点的直接前驱（$2\\le i\\le N$）"  "在第$i$个结点后插入一个新结点（$1\\le i\\le N$）"  "删除第$i$个结点（$1\\le i\\le N$）"  "将$N$个结点从小到大排序"]   答案：A

题目18:以下关于顺序表的说法中，正确的是（ ）。  choices=["顺序表可以利用一维数组表示，因此顺序表与一维数组在结构上是一致的，它们可以通用"  "在顺序表中，逻辑上相邻的元素在物理位置上不一定相邻"  "顺序表和一维数组一样，都可以按下标随机（或直接）访问，顺序表还可以从某一指定元素开始，向前或向后逐个元素顺序访问"  "在顺序表中每一表元素的数据类型还可以是顺序表"]   答案：C

题目19:线性表若采用链式存储结构时，要求内存中可用存储单元的地址  choices=["必须是连续的"  "连续或不连续都可以"  "部分地址必须是连续的"  "一定是不连续的"]   答案：B

题目20:线性表L在什么情况下适用于使用链式结构实现？  choices=["需不断对L进行删除插入"  "需经常修改L中的结点值"  "L中含有大量的结点"  "L中结点结构复杂"]   答案：B

题目21:链表不具有的特点是：  choices=["插入、删除不需要移动元素"  "方便随机访问任一元素"  "不必事先估计存储空间"  "所需空间与线性长度成正比"]   答案：B

题目22:适用于压缩存储稀疏矩阵的两种存储结构是：  choices=["三元组表和十字链表"  "三元组表和邻接矩阵"  "十字链表和二叉链表"  "邻接矩阵和十字链表"]   答案：A

题目23:在具有$N$个结点的单链表中，实现下列哪个操作，其算法的时间复杂度是$O(N)？  choices=["在地址为$p$的结点之后插入一个结点"  "删除开始结点"  "遍历链表和求链表的第$i$个结点"  "删除地址为$p$的结点的后继结点"]   答案：C

题目24:某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用什么存储方式最节省运算时间？  choices=["单链表"  "仅有尾指针的单循环链表"  "仅有头指针的单循环链表"  "双链表"]   答案：B

题目25:若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点。则采用哪种存储方式最节省运算时间？  choices=["单链表"  "双链表"  "单循环链表"  "带头结点的双循环链表"]   答案：D

题目26:将线性表La和Lb头尾连接，要求时间复杂度为O(1)，且占用辅助空间尽量小。应该使用哪种结构？  choices=["单链表"  "单循环链表"  "带尾指针的单循环链表"  "带头结点的双循环链表"]   答案：C

题目27:对于一个具有$N$个结点的单链表，在给定值为$x$的结点后插入一个新结点的时间复杂度为  choices=["$O(1)"  "$O(N/2)"  "$O(N)"  "$O(N^2)"]   答案：C

题目28:设`h`为不带头结点的单向链表。在`h`的头上插入一个新结点`t`的语句是：  choices=["`h=t; t->next=h->next;`"  "`t->next=h->next; h=t;`"  "`h=t; t->next=h;`"  "`t->next=h; h=t;`"]   答案：D

题目29:在单链表中，若`p`所指的结点不是最后结点，在`p`之后插入`s`所指结点，则执行  choices=["`s->next=p; p->next=s;`"  "`s->next=p->next; p=s;`"  "`s->next=p->next; p->next=s;`"  "`p->next=s; s->next=p;`"]   答案：A

题目30:带头结点的单链表`h`为空的判定条件是：  choices=["`h == NULL;`"  "`h->next == NULL;`"  "`h->next == h;`"  "`h != NULL;`"]   答案：B

题目31:对于一非空的循环单链表，`h`和`p`分别指向链表的头、尾结点，则有：  choices=["`p->next == h`"  "`p->next == NULL`"  "`p == NULL`"  "`p == h`"]   答案：A

题目32:将两个结点数都为$N$且都从小到大有序的单向链表合并成一个从小到大有序的单向链表，那么可能的最少比较次数是：  choices=["$1$"  "$N$"  "$2N$"  "$NlogN$"]   答案：B

题目33:已知表头元素为`c`的单链表在内存中的存储状态如下表所示：

![](~/124)

现将`f`存放于`1014H`处，并插入到单链表中，若`f`在逻辑上位于`a`和`e`之间，则`a`、`e`、`f`的“链接地址”依次

是：  choices=["`1010H`   `1014H`   `1004H`"  "`1010H`   `1004H`   `1014H`"  "`1014H`   `1010H`   `1004H`"  "`1014H`   `1004H`   `1010H`"]   答案：C

题目34:链表不具有的特点是\_\_\_\_。  choices=["可随机访问任一元素"  "插入、删除不需要移动元素"  "不必事先估计存储空间"  "所需空间与线性表长度成正比"]   答案：A

题目35:以下说法错误的是  (  )。  choices=["对于线性表来说，定位运算LocateElem在顺序表和单链表上的时间复杂度均为O（n）"  "插入、删除操作在顺序表上的实现，平均时间复杂度为O（n）"  "在链表上实现读表元运算的平均时间复杂度为O（1）"  "插入、删除操作在链表上的实现可在O（1）时间内完成"]   答案：C

题目36:线性表、堆栈、队列的主要区别是什么？  choices=["线性表用指针，堆栈和队列用数组"  "堆栈和队列都是插入、删除受到约束的线性表"  "线性表和队列都可以用循环链表实现，但堆栈不能"  "堆栈和队列都不是线性结构，而线性表是"]   答案：B

题目37:现有队列 Q 与栈 S，初始时 Q 中的元素依次是{ 1, 2, 3, 4, 5, 6 }（1在队头），S 为空。若允许下列3种操作：（1）出队并输出出队元素；（2）出队并将出队元素入栈；（3）出栈并输出出栈元素，则不能得到的输出序列是：  choices=["1   2   5   6   4   3"  "2   3   4   5   6   1"  "3   4   5   6   1   2"  "6   5   4   3   2   1"]   答案：C

题目38:若栈$S_1$中保存整数，栈$S_2$中保存运算符，函数`F()`依次执行下述各步操作：

- （1）从$S_1$中依次弹出两个操作数`a`和`b`；
- （2）从$S_2$中弹出一个运算符`op`；
- （3）执行相应的运算`b op a`；
- （4）将运算结果压入$S_1$中。

假定$S_1$中的操作数依次是{ 5, 8, 3, 2 }（2在栈顶），$S_2$中的运算符依次是{ `*`, `-`, `+` }（+在栈顶）。调用3次`F()`后，$S_1$栈顶保存的值是：  choices=["-15"  "15"  "-20"  "20"]   答案：B

题目39:若用大小为6的数组来实现循环队列，且当前`front`和`rear`的值分别为0和4。当从队列中删除两个元素，再加入两个元素后，`front`和`rear`的值分别为多少？  choices=["2和0"  "2和2"  "2和4"  "2和6"]   答案：A

题目40:在一个不带头结点的非空链式队列中,假设f和r分别为队头和队尾指针,则插入s所指的结点运算是(  )。  choices=["f->next=s; f=s;"  "r->next=s; r=s;"  "s->next=s; r=s;"  "s->next=f; f=s;"]   答案：B

题目41:假设有5个整数以1、2、3、4、5的顺序被压入堆栈，且出栈顺序为3、5、4、2、1，那么为了获得这样的输出，堆栈大小至少为：  choices=["2"  "3"  "4"  "5"]   答案：C

题目42:若元素a、b、c、d、e、f依次进栈，允许进栈、退栈操作交替进行，但不允许连续三次进行退栈工作，则不可能得到的出栈序列是？  choices=["b c a e f d"  "c b d a e f"  "d c e b f a"  "a f e d c b"]   答案：D

题目43:设一个栈的输入序列是1、2、3、4、5，则下列序列中，是栈的合法输出序列的是？  choices=["3 2 1 5 4"  "5 1 2 3 4"  "4 5 1 3 2"  "4 3 1 2 5"]   答案：A

题目44:有六个元素以6、5、4、3、2、1的顺序进栈，问哪个不是合法的出栈序列？  choices=["2 3 4 1 5 6"  "3 4 6 5 2 1"  "5 4 3 6 1 2"  "4 5 3 1 2 6"]   答案：B

题目45:令P代表入栈，O代表出栈。若利用堆栈将中缀表达式`3*2+8/4`转为后缀表达式，则相应的堆栈操作序列是：  choices=["PPPOOO"  "POPOPO"  "POPPOO"  "PPOOPO"]   答案：C

题目46:表达式`a*(b+c)-d`的后缀表达式是：  choices=["`a b c + * d -`"  "`a b c d * + -`"  "`a b c * + d -`"  "`- + * a b c d`"]   答案：A

题目47:若`top`为指向栈顶元素的指针，判定栈`S`（最多容纳`m`个元素）为空的条件是：  choices=["`S->top == 0`"  "`S->top == -1`"  "`S->top != m-1`"  "`S->top == m-1`"]   答案：B

题目48:若栈采用顺序存储方式存储，现两栈共享空间`V[m]`：`top[i]`代表第`i`（`i`=1或2）个栈的栈顶；栈1的底在`V[0]`，栈2的底在`V[m-1]`，则栈满的条件是：  choices=["`|top[2]-top[1]|==0`"  "`top[1]+top[2]==m`"  "`top[1]==top[2]`"  "`top[1]+1==top[2]`"]   答案：D

题目49:设栈S和队列Q的初始状态均为空，元素{1, 2, 3, 4, 5, 6, 7}依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是{2, 5, 6, 4, 7, 3, 1}，则栈S的容量至少是：  choices=["1"  "2"  "3"  "4"]   答案：D

题目50:给定一个堆栈的入栈序列为{ 1, 2, \cdots$, $n$ }，出栈序列为{ $p_1$, $p_2$, \cdots$, $p_n$ }。如果$p_2 = n$，则存在多少种不同的出栈序列？  choices=["$n$"  "$n-1$"  "2"  "1"]   答案：B


------------------------------------------
题目1:
题目：打印沙漏 20 分难度：7-1
正文：
本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印
```
*****
 ***
  *
 ***
*****
```

所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。

给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。


### 输入格式:

输入在一行给出1个正整数N（\le$$1000）和一个符号，中间以空格分隔。

### 输出格式:

首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。

### 输入样例:
```in
19 *
```

### 输出样例:
```out
*****
 ***
  *
 ***
*****
2
```

答案：
#include<iostream>
using namespace std;
int len=0;
int main(){
	int n;
	char c;
	cin>>n>>c;
	int sum=0;
	for(len=0;sum<=n;++len){
		sum+=(2*len+1)*(len==0?1:2);
	}
	
	
	len--;	
	if(sum>n)
		sum-=(2*len+1)*(len==0?1:2);
	
	
	len=len*2-1;
	
//	cout<<"sum="<<sum<<" len="<<len<<endl;
	
	
	for(int i=0;i<len/2;++i){
		for(int j=0;j<i;++j){
			cout<<" ";
		}
		for(int j=0;j<2*(len/2-i)+1;++j){
			cout<<c;
		}
		cout<<endl;
	}
	
	
	for(int i=len/2;i>=0;--i){
		for(int j=0;j<i;++j){
			cout<<" ";
		}
		for(int j=0;j<2*(len/2-i)+1;++j){
			cout<<c;
		}
		cout<<endl;
		
		
	}
	cout<<n-sum<<endl;
	
	return 0;
} 

------------------------


题目2:
题目：素数对猜想 20 分难度：7-2
正文：
让我们定义$d_n$为：$d_n = p_{n+1}-p_n$，其中$p_i$是第$i$个素数。显然有$d_1 = 1$，且对于$n>1$有$d_n$是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。

现给定任意正整数`N`(<10^5$)，请计算不超过`N`的满足猜想的素数对的个数。


### 输入格式:

输入在一行给出正整数`N`。

### 输出格式:

在一行中输出不超过`N`的满足猜想的素数对的个数。

### 输入样例:
```in
20
```

### 输出样例:
```out
4
```

答案：

#include<iostream>
#include<math.h>
using namespace std; 

int isPrime(int n)
{	//返回1表示判断为质数，0为非质数，在此没有进行输入异常检测
	float n_sqrt;
	if(n==2 || n==3) return 1;
	if(n%6!=1 && n%6!=5) return 0;
	n_sqrt=floor(sqrt((float)n));
	for(int i=5;i<=n_sqrt;i+=6)
	{
	    if(n%(i)==0 | n%(i+2)==0) return 0;
	}
        return 1;
} 

int main(){
	int n;
	cin>>n;
	int sum=0;
	for(int i=2;i<=n;){
		if(i%2!=0){
			if((i+2<=n)&&isPrime(i)&&isPrime(i+2)){
				++sum;
				++i;
			}
		}
		++i;
	} 
	cout<<sum<<endl;
	return 0;
}

------------------------


题目3:
题目：数组元素循环右移问题 20 分难度：7-3
正文：
一个数组$A$中存有$N$（>0$）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移$M$（\ge 0$）个位置，即将$A$中的数据由（$A_0 A_1 \cdots A_{N-1}）变换为（$A_{N-M} \cdots A_{N-1} A_0 A_1 \cdots A_{N-M-1}）（最后$M$个数循环移至最前面的$M$个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

### 输入格式:

每个输入包含一个测试用例，第1行输入$N$（$1\le N \le 100$）和$M$（\ge 0$）；第2行输入$N$个整数，之间用空格分隔。

### 输出格式:

在一行中输出循环右移$M$位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。

### 输入样例:
```in
6 2
1 2 3 4 5 6
```

### 输出样例:
```out
5 6 1 2 3 4
```

答案：

#include<iostream>
using namespace std; 
#define MAXn 102 
int nums[MAXn]={0};
int main(void){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<n;++i){
		cin>>nums[i];
	}
	int t;
	while(m--){
		t=nums[n-1];
		for(int i=n-1;i>0;--i){
			nums[i]=nums[i-1]; 
		}
		nums[0]=t;
	}
	
	for(int i=0;i<n-1;++i){
		cout<<nums[i]<<" ";
	}
    cout<<nums[n-1];
	
	return 0;
}

------------------------


题目4:
题目：两个有序链表序列的合并 20 分难度：7-14
正文：
已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。

### 输入格式:

输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用-1$表示序列的结尾（-1$不属于这个序列）。数字用空格间隔。

### 输出格式:

在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出`NULL`。

### 输入样例:
```in
1 3 5 -1
2 4 6 8 10 -1
```

### 输出样例:
```out
1 2 3 4 5 6 8 10
```

答案：
#include<iostream>
#include<stdlib.h>
#include<string.h>
using namespace std;

typedef struct Node *ProNode;
typedef int Elmentype;
struct Node{
	Elmentype Data;
	ProNode Next;
};
ProNode read(){
	ProNode head,temp,end;
	Elmentype data;
	
	head=temp=end=NULL;
	while(1){
		scanf("%d",&data);
		if(data==-1){
			
			break;
		}
		
	//	cout<<"data="<<data<<endl;
		temp=(ProNode)malloc(sizeof(struct Node));
		temp->Data=data;
		if(end!=NULL){
			end->Next=temp;
			end=temp;
			end->Next=NULL;
		}else{
			head=temp;
			head->Next=NULL;
			end=head;
		}
	}
	return head;
	
}
ProNode insert(ProNode List, Elmentype _Data){
	if(List==NULL){
		List=(ProNode)malloc(sizeof(struct Node));
		List->Data=_Data;
		List->Next=NULL;
		return List;
	}
	
	ProNode Head=List;
	while(List&&List->Next!=NULL){
		List=List->Next;
	}
	
	List->Next=(ProNode)malloc(sizeof(struct Node));
	List->Next->Data=_Data;
	List->Next->Next=NULL;
	
	return Head;
}

ProNode getList(ProNode List){
	ProNode tlist=List;
	List=List->Next;
//	cout<<"tlist->data"<<tlist->Data<<"\n";
	return tlist;
}
ProNode hebin(ProNode list1,ProNode list2){
	if(list1==NULL&&list2==NULL){
		return NULL;
	}
	
	
	ProNode head,Temp,end;
	head=Temp=end=NULL;
	//head=( (list1->Data)<(list2->Data)?getList(list1):getList(list2));
	
	if(list1->Data<=list2->Data){
		head=list1;
		list1=list1->Next;
	}else{
		head=list2;
		list2=list2->Next;
	}
	
	end=head;
	end->Next=NULL;
	while(list1&&list2){
		//Temp=( (list1->Data)<(list2->Data)?getList(list1):getList(list2));
		if((list1->Data)<=(list2->Data)){
			Temp=list1;
			list1=list1->Next;
		}else{
			Temp=list2;
			list2=list2->Next;
		}
		end->Next=Temp;
		end=Temp;
		end->Next=NULL;
	}
	while(list1){
		Temp=list1;
		list1=list1->Next;
		end->Next=Temp;
		end=Temp;
		end->Next=NULL;
	}
	while(list2){
		Temp=list2;
		list2=list2->Next;
		end->Next=Temp;
		end=Temp;
		end->Next=NULL;
	}
	

	
	
	return head;
	
}
int main(){
	ProNode head1,head2,head3;
	head1=head2=head3=NULL;
	
	
	head1=read();
	head2=read(); 
	//Elmentype t;
	
//	while(1){
//		scanf("%d",&t);
//		if(t==-1){
//			break;
//		}
//		head1=insert(head1,t);
//	}
//	
//
//
//	while(1){
//		scanf("%d",&t);
//		if(t==-1){
//			break;
//		}
//		head2=insert(head2,t);
//	}	
	
	


	head3=hebin(head1,head2);


	if(head3==NULL){
		cout<<"NULL"<<endl;
		return 0;
	}
	
	int falg=1;
	while(head3){
		if(falg){
			printf("%d",head3->Data);
			falg=0;
		}else{
			printf(" %d",head3->Data);
		}
		
		head3=head3->Next;
	}
	
	return 0;
} 

------------------------


题目5:
题目：堆栈操作合法性 20 分难度：7-6
正文：
假设以`S`和`X`分别表示入栈和出栈操作。如果根据一个仅由`S`和`X`构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入`S`和`X`序列，判断该序列是否合法。

### 输入格式:

输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（\le 50$）是堆栈的最大容量。随后N行，每行中给出一个仅由`S`和`X`构成的序列。序列保证不为空，且长度不超过100。

### 输出格式:

对每个序列，在一行中输出`YES`如果该序列是合法的堆栈操作序列，或`NO`如果不是。

### 输入样例：
```in
4 10
SSSXXSXXSX
SSSXXSXXS
SSSSSSSSSSXSSXXXXXXXXXXX
SSSXXSXXX
```

### 输出样例：
```out
YES
NO
NO
NO
```

答案：
#include<iostream>
#include<stack>
#include<string>
using namespace std;

int main()
{
   int n,m;
   cin >> n >> m;
   string str;
   for(int i=0;i<n;i++)
   {  
      bool flag = true;
      cin >> str;
      stack<int> s;
      for(int j=0;j<str.size();j++)
      {
         if(str[j] == 'S')
         {
            if(s.size() < m)
            s.push(1);
            else 
            {
               flag = false;
               break;
            }
         }
         else 
         {
            if( !s.empty() )
            s.pop();
            else 
            {
               flag = false;
               break;
            }
         }
      }
      if(!s.empty())
      flag = false;
      if(flag)
      cout << "YES" <<endl;
      else 
      cout << "NO" <<endl;
   }
}

------------------------


题目6:
题目：后缀式求值 25 分难度：7-7
正文：
我们人类习惯于书写“中缀式”，如 `3 + 5 * 2` ，其值为`13`。 (p.s. 为什么人类习惯中缀式呢？是因为中缀式比后缀式好用么？）<br>
而计算机更加习惯“后缀式”（也叫“逆波兰式”，Reverse Polish Notation）。上述中缀式对应的后缀式是： `3 5 2 * +` <br>
现在，请对输入的后缀式进行求值。

### 输入格式:

在一行中输入一个后缀式，`运算数`和`运算符`之间用空格分隔，运算数长度不超过`6`位，运算符仅有`+ - * /` 四种。

### 输出格式:

在一行中输出后缀式的值，保留一位小数。

### 输入样例:
```in
3 5.4 2.2 * +
```

### 输出样例:
```out
14.9
```


答案：
#include<iostream>
#include<stack>
#include<string>
#include<sstream>
#include<map>

using namespace std;
stack<double> s;
map<char ,int> Map; 
void init(){
	Map['+']=0;
	Map['-']=0;
	Map['*']=1;
	Map['/']=1;
	Map['(']=-1;
}
int main(){
	
	string str;
	getline(cin,str);
	istringstream strt(str);
	int len=str.length();
	
	double res=0;
	string t;
	strt>>t;
	while(t.length()>0){
	//	cout<<"t="<<t<<endl;
		if(t.length()==1&&(t=="*"||t=="/"||t=="+"||t=="-")){
			double b=s.top();
	//		cout<<"a="<<a<<endl;
			s.pop();
			double a=s.top();
		//	cout<<"b="<<b<<endl;
			s.pop();

			if(t=="+"){
				s.push(a+b);
			}
			else if(t=="-"){
				s.push(a-b);
			}
			else if(t=="*"){
				s.push(a*b);
			}
			else if(t=="/"){
				s.push(a/b);
			}
			
		}else{
//			char *tt=t.;
			stringstream strs(t);
			double tin;
			strs>>tin;
			s.push(tin);
		}
		
		
		
		
		
	//	cout<<"t.top()="<<s.top()<<endl;
		
		
		
		
		
		
		
		
		
		t="";
		strt>>t;
		
	}
	
	printf("%.1lf",s.top());
//	istringstream ss("123 23 4");
//	
////	cout<<ss.str()<<endl;
//	string a;
//	ss>>a;
//	cout<<a<<endl;
	return 0;
} 

------------------------


题目7:
题目：表达式转换 25 分难度：7-8
正文：
算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。

### 输入格式:

输入在一行中给出不含空格的中缀表达式，可包含`+`、`-`、`*`、`\`以及左右括号`()`，表达式不超过20个字符。

### 输出格式:

在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。

### 输入样例:
```in
2+3*(7-4)+8/4
```

### 输出样例:
```out
2 3 7 4 - * + 8 4 / +
```

答案：
///**
//求后缀表达式
//1。扫描字符串
//2.判断字符
//3.数字或者小数点，输出
//
//4.* / + - 把优先级大于等于本字符的弹出，直到自己遇到最小，或者栈底
//
//5.（ 优先级最低，直接入栈
//6.） 一直弹栈，直到遇到（ 括号 
//
//
//*/
//
//#include<iostream>
//#include<string.h>
//#include<stack>
//#include<map>
//using namespace std;
//map<char,int> priority;
//map<char ,int> Map; 
//stack<char> s;
//int main(){
//	Map['+']=0;
//	Map['-']=0;
//	Map['*']=1;
//	Map['/']=1;
//	Map['(']=-1;
//	
//	string str;
//	string str2;
//	cin>>str;
//	int len=str.length();
//	int flag=1;
//	for(int i=0;i<len;){
//		int hasnum=0;
//		while((str[i]>='0'&&str[i]<='9')||str[i+1]=='.'){
////			if(flag||str[i-1]=='.'||(str[i-1]>='0'&&str[i-1]<='9')){
////				flag=0; 
////				cout<<str[i];
////			}else if(!(str[i-1]>='0'&&str[i-1]<='9')&&str[i-1]!='.'){
////				cout<<" "<<str[i];
////			}	
//			hasnum=1;
//			str2+=str[i]; 
//			cout<<str[i];
//			if(str[i+1]=='.'){	
//				cout<<".";
//				str2+=str[i+1];
//				++i;
//			}
//			++i;
//		}
//		if(hasnum){
//			str2+=' ';
//			cout<<" ";
//		}
//		//字符弹出 
//		if(str[i]=='*'||str[i]=='/'||str[i]=='+'||str[i]=='-'){
//			while(!s.empty()&&Map[str[i]]<=Map[s.top()]){
//				str2+=(s.top());
//				str2+=' ';
////				if(flag){
////					flag=0; 
////					cout<<s.top();
////				}else{
////					cout<<" "<<s.top();
////				}	
//				cout<<s.top()<<" ";
//				s.pop();
//			}
//			s.push(str[i]);
//			++i;
//		}
//		if(str[i]=='(')
//		{
//			s.push(str[i]);
//			++i;
//		 }
//		 if(str[i]==')'){
//		 	while(s.top()!='('){
//		 		str2+=(s.top());
//		 		str2+=' ';
////		 		if(flag){
////		 			flag=0; 
////					cout<<s.top();
////				}else{
////					cout<<" "<<s.top();
////				}
//				cout<<s.top()<<" ";
//		 		s.pop();
//			 }
//			 s.pop();//(左括号弹出，不输出 
//		 	++i;
//		 }
//	}
//	while(!s.empty()){
//		str2+=(s.top());
//		str2+=' ';
//		cout<<s.top()<<" ";
////			cout<<" "<<s.top();
//		   s.pop();
//	}
////	cout<<"\n------------------\n";
////	cout<<str2<<endl;
//	//str2[str2.length()-1]='\0';
////	cout<<str2;
//	return 0;
//} 


/**
求后缀表达式
1。扫描字符串
2.判断字符
3.数字或者小数点，输出

4.* / + - 把优先级大于等于本字符的弹出，直到自己遇到最小，或者栈底

5.（ 优先级最低，直接入栈
6.） 一直弹栈，直到遇到（ 括号 


*/

#include<iostream>
#include<string.h>
#include<stack>
#include<map>
using namespace std;
map<char,int> priority;
map<char ,int> Map; 
stack<char> s;
int main(){
	Map['+']=0;
	Map['-']=0;
	Map['*']=1;
	Map['/']=1;
	Map['(']=-1;
	
	string str;
	string str2;
	cin>>str;
	int len=str.length();
	int flag=1;
	for(int i=0;i<len;){
		int hasnum=0;
		while((str[i]>='0'&&str[i]<='9')||str[i+1]=='.'){
//			if(flag||str[i-1]=='.'||(str[i-1]>='0'&&str[i-1]<='9')){
//				flag=0; 
//				cout<<str[i];
//			}else if(!(str[i-1]>='0'&&str[i-1]<='9')&&str[i-1]!='.'){
//				cout<<" "<<str[i];
//			}	
			hasnum=1;
			str2+=str[i]; 
			if(str[i+1]=='.'){	
				//cout<<".";
				str2+=str[i+1];
				++i;
			}
			++i;
		}
		if(hasnum){
			str2+=' ';
		}
		//字符弹出 
		if(  (str[i]=='*'||str[i]=='/'||str[i]=='+'||str[i]=='-') ){
			if(i==0||(str[i-1]=='*'||str[i-1]=='/'||str[i-1]=='+'||str[i-1]=='-'||str[i-1]=='(')){
				if(str[i]=='-'){
					str2+=str[i];
				}
				//cout<<"q"<<str[i]<<endl; 
				++i;
			}else{
				
				while(!s.empty()&&Map[str[i]]<=Map[s.top()]){
					str2+=(s.top());
					str2+=' ';
	//				if(flag){
	//					flag=0; 
	//					cout<<s.top();
	//				}else{
	//					cout<<" "<<s.top();
	//				}	
					s.pop();
				}
				s.push(str[i]);
				++i;
			}
			
			
		}
		//else if((str[i]=='*'||str[i]=='/'||str[i]=='+'||str[i]=='-')&&(str[i-1]=='*'||str[i-1]=='/'||str[i-1]=='+'||str[i-1]=='-')){
		//	cout<<"q"<<str[i]<<endl;
		//	str2+=str[i];
	///	}
		if(str[i]=='(')
		{
			s.push(str[i]);
			++i;
		 }
		 if(str[i]==')'){
		 	while(s.top()!='('){
		 		str2+=(s.top());
		 		str2+=' ';
//		 		if(flag){
//		 			flag=0; 
//					cout<<s.top();
//				}else{
//					cout<<" "<<s.top();
//				}
		 		s.pop();
			 }
			 s.pop();//(左括号弹出，不输出 
		 	++i;
		 }
	}
	while(!s.empty()){
		str2+=(s.top());
		str2+=' ';
//			cout<<" "<<s.top();
		   s.pop();
	}
//	cout<<"\n------------------\n";
//	cout<<str2<<endl;
	str2[str2.length()-1]='\0';
	cout<<str2;
	return 0;
} 

------------------------


题目8:
题目：汉诺塔问题 10 分难度：7-4
正文：
汉诺塔是一个源于印度古老传说的益智玩具。据说大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘，大梵天命令僧侣把圆盘移到另一根柱子上，并且规定：在小圆盘上不能放大圆盘，每次只能移动一个圆盘。当所有圆盘都移到另一根柱子上时，世界就会毁灭。

![题图1.jpg](~/eac25442-22c9-4b87-8cf8-e8a69ea0cf02.jpg)

请编写程序，输入汉诺塔圆片的数量，输出移动汉诺塔的步骤。

#### 输入格式
> 圆盘数
> 起始柱 目的柱 过度柱

#### 输出格式
> 移动汉诺塔的步骤  
> 每行显示一步操作，具体格式为：  
> 盘片号: 起始柱 -> 目的柱  
> 其中盘片号从 1 开始由小到大顺序编号。

#### 输入样例
```in
3
a c b
```
#### 输出样例

```out
1: a -> c
2: a -> b
1: c -> b
3: a -> c
1: b -> a
2: b -> c
1: a -> c
```


答案：
/*
汉诺塔是一个源于印度古老传说的益智玩具。
据说大梵天创造世界的时候做了三根金刚石柱子，
在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘，
大梵天命令僧侣把圆盘移到另一根柱子上，并且规定：在小圆盘上不能放大圆盘，
每次只能移动一个圆盘。当所有圆盘都移到另一根柱子上时，世界就会毁灭。

*/ 

#include<iostream>
using namespace std;
int n;
char a,b,c;

void han(int n,char a,char b,char c){
	if(n==1){
		cout<<n<<": "<<a<<" -> "<<b<<endl;
	}else{
		han(n-1,a,c,b);
		cout<<n<<": "<<a<<" -> "<<b<<endl;
		han(n-1,c,b,a);
	}
}

int main(){
	cin>>n;
	cin>>a>>b>>c;
	han(n,a,b,c); 
	
	return 0;
} 

------------------------


题目9:
题目：约瑟夫环问题-hebust 10 分难度：7-9
正文：
约瑟夫环问题

约瑟夫环是一个数学的应用问题：已知n个人（以编号a，b，c...分别表示）围坐在一张圆桌周围。从编号为1的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。

### 输入格式:
固定为2行，第一行为m，第二行为n个人的名称列表，用英文字母代表，元素直接使用英文逗号 ， 分开

### 输出格式:
一行，为出列元素序列，元素之间使用英文逗号 ， 分开【注意：末尾元素后没有逗号】

### 输入样例:

在这里给出一组输入。例如：

```in
3
a,b,c,d,e,f,g
```

### 输出样例:

在这里给出相应的输出。例如：

```out
c,f,b,g,e,a,d
```

答案：
#include<iostream>
#include<string.h>
#include<queue> 
using namespace std;
int num=0;
char* split(string str,char reg){
	int l=str.length();
	char* res=new char[l];
	for(int i=0;i<l;++i){
		if(str[i]!=reg){	
			res[num++]=str[i];
		}
	}
	return res;
}

queue<char>q;
int main(){
	
	int m;
	int n;
	cin>>m;
	
	string str;
	cin>>str;
	getchar();
	char *t=split(str,',');
	
	for(int i=0;i<num;++i){
		q.push(*(t+i));
	}
	
	int falg=1;
	while(!q.empty()){
		for(int i=0;i<m-1;++i){
			if(!q.empty()){
				q.push(q.front());
				q.pop();
			}
		}
	
		char c=q.front();q.pop();
		if(falg){
			cout<<c;
			falg=0;
		}else{
			cout<<","<<c;
		}
		
	}
		
	return 0;
}

------------------------


题目10:
题目：两个有序链表序列的交集 20 分难度：7-10
正文：
已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。

### 输入格式:

输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用-1$表示序列的结尾（-1$不属于这个序列）。数字用空格间隔。

### 输出格式:

在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出`NULL`。

### 输入样例:
```in
1 2 5 -1
2 4 5 8 10 -1
```

### 输出样例:
```out
2 5
```

答案：
#include<iostream>
#include<queue>
using namespace std;

int main()
{
	queue<int> a,b;
	int x,cnt=0;
	while(cin >>x && x!=-1)
	a.push(x);
	while(cin >> x && x!= -1)
	b.push(x);
	bool flag = true;
	while(!a.empty() && !b.empty() )
	{
		if(a.front() == b.front())
		{
			if(flag)
			{
				flag = false;
				cout << a.front();
			}
			else 
			{
				cout <<" " << a.front();
			}
			a.pop();
			b.pop();
			cnt ++;
		}
		else if(a.front() > b.front())
		{
			while(a.front() > b.front() && !b.empty())
			b.pop();
		}
		else 
		{
			while(a.front() < b.front() && !a.empty())
			a.pop();
		}
	}
	if(!cnt)
	cout << "NULL";
    return 0;
}

------------------------


题目11:
题目：列车调度 25 分难度：7-11
正文：
火车站的列车调度铁轨的结构如下图所示。


![](~/188)

两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有`N`条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？

### 输入格式：

输入第一行给出一个整数`N` (2 \le$ `N` \le 10^5$)，下一行给出从1到`N`的整数序号的一个重排列。数字间以空格分隔。

### 输出格式：

在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。

### 输入样例：
```in
9
8 4 2 5 3 9 1 6 7
```

### 输出样例：
```out
4
```

答案：
#include<iostream>
using namespace std;
int a[(int)1e5+1];
int ans;
int main()
{   
    int n,t;
    cin >> n;
    for(int i=0;i<n;++i){
        cin >> t;
        if(!i || t > a[ans-1]  )
        {
            a[ans++] = t;
        }
        else 
        {
            int pos = lower_bound(a,a+ans,t)-a;
            a[pos] = t;
        }
    }
    cout << ans <<endl;
    return 0;
}

------------------------


题目12:
题目：二分查找 25 分难度：7-12
正文：
请实现有重复数字的有序数组的二分查找。

输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。

### 输入格式:

输入第一行有两个数，第一个数为数组长度n（≤10^6），第二个数为需要查找的数。

接下来有n个整数，以空格或换行符分隔。

### 输出格式:

输出待查找的数的位置。

### 输入样例:


```in
5 4
1 2 4 4 5
```

### 输出样例:


```out
3
```

### 样例解释:
```
有5个数，查找4出现的位置，4第一次出现在第3个位置，所以输出3。
```


答案：
#include<iostream>
using namespace std;
int a[1000005];
int f(int val,int size)
{
    int left = 0, right = size - 1, mid;
    while(left <= right) 
    {
        mid = left + (right - left) / 2;
        if(a[mid] >= val) 
            right = mid - 1;
        else 
            left = mid + 1 ;
    }
    return left;
}
int main()
{   
    int n,m;
    scanf("%d %d\n",&n,&m);
    for(int i=0;i<n;i++)
    scanf("%d",&a[i]);
    int pos = f(m,n);
    if(pos == n)
    cout << n+1 <<endl;
    else 
    cout << pos+1 <<endl;
   // system("pause");
}

------------------------


题目13:
题目：建立与遍历二叉树 25 分难度：7-13
正文：
以字符串的形式定义一棵二叉树的先序序列，若字符是‘#’, 表示该二叉树是空树，否则该字符是相应结点的数据元素。读入相应先序序列，建立**二叉链式存储结构**的二叉树，然后中序遍历该二叉树并输出结点数据。
### 输入格式:

字符串形式的先序序列（即结点的数据类型为单个字符）

### 输出格式:

中序遍历结果

### 输入样例:

在这里给出一组输入。例如：

```in
ABC##DE#G##F###
```

### 输出样例:

在这里给出相应的输出。例如：

```out
CBEGDFA
```


答案：
#include<iostream>
using namespace std;
typedef char ElemType;
typedef struct BitNode{
	ElemType date;
	struct BitNode* left;
	struct BitNode* right;
}*trrePtr;
void init(trrePtr &root){
	char c;
	cin>>c;
	if(c=='#'){
		root=NULL;
	}else{
		root=new BitNode;
		root->date=c;
		init(root->left);
		init(root->right);
	} 
}
void midShow(trrePtr root){
	if(root){
		midShow(root->left);	
		cout<<root->date;
		midShow(root->right);
	}
}
int main(){
	trrePtr root=NULL;
	init(root);
	midShow(root);
	return 0;
} 

------------------------


题目14:
题目：根据后序和中序遍历输出先序遍历 25 分难度：7-15
正文：
本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。

### 输入格式:

第一行给出正整数$N$(\le 30$)，是树中结点的个数。随后两行，每行给出$N$个整数，分别对应后序遍历和中序遍历结果，数字间以空格分隔。题目保证输入正确对应一棵二叉树。

### 输出格式:

在一行中输出`Preorder: `以及该树的先序遍历结果。数字间有1个空格，行末不得有多余空格。

### 输入样例:
```in
7
2 3 1 5 7 6 4
1 2 3 4 5 6 7
```

### 输出样例:
```out
Preorder: 4 1 3 2 6 5 7
```

答案：
#include<iostream>
using namespace std;
#define MAX 33
int numh[MAX]={0};
int numz[MAX]={0};
void qian(int lh,int rh,int lz,int rz){
	if(lh>rh||lz>rz){
		return;	
	}
		cout<<" "<<numh[rh];
		int i;
		for(i=lz;i<=rz;++i){
			if(numz[i]==numh[rh]){
				qian(lh,lh+(i-lz-1),lz,i-1);
				qian(lh+(i-lz),rh-1,i+1,rz);
				return;
			}
		}
} 
 
int main(){
 	int n;
 	cin>>n;
 	int t;
 	for(int i=0;i<n;++i){
 		cin>>t;
 		numh[i]=t;
	 }
	 for(int i=0;i<n;++i){
	 	cin>>t;
	 	numz[i]=t;
	 }
	 cout<<"Preorder:";
	 qian(0,n-1,0,n-1);
 	
 	return 0;
}

------------------------


题目15:
题目：是否同一棵二叉搜索树 25 分难度：7-16
正文：
给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。

### 输入格式:

输入包含若干组测试数据。每组数据的第1行给出两个正整数$N$ (\le 10$)和$L$，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出$N$个以空格分隔的正整数，作为初始插入序列。最后$L$行，每行给出$N$个插入的元素，属于$L$个需要检查的序列。

简单起见，我们保证每个插入序列都是1到$N$的一个排列。当读到$N$为0时，标志输入结束，这组数据不要处理。

### 输出格式:

对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。

### 输入样例:
```in
4 2
3 1 4 2
3 4 1 2
3 2 4 1
2 1
2 1
1 2
0
```

### 输出样例:
```out
Yes
No
No
```

**鸣谢青岛大学周强老师补充测试数据！**

答案：
#include <iostream>
using namespace std;
struct Node{
    int data;
    Node * left;
    Node * right;
};
typedef Node* Tree;
Tree insert(Tree BT,int x){//创建树
    if(!BT){
        BT=new(Node);
        BT->data=x;
        BT->left=BT->right=NULL;
    }
    else if(x<BT->data)
        BT->left=insert(BT->left,x);
    else if(x>BT->data)
        BT->right=insert(BT->right,x);
    return BT;
}
bool judgeidentical(Tree a,Tree b){//判断两棵树是否一致
    if(a==NULL&&b==NULL)
        return true;
    else if((a!=NULL&&b==NULL)||(a==NULL&&b!=NULL))
        return false;
    else if(a->data==b->data)
        return judgeidentical(a->left,b->left)&&judgeidentical(a->right,b->right);
    return false;
}
int main(){
    int n,l,x;
    while(cin>>n&&n){
        cin>>l;
        Tree BT=NULL;
        for(int i=0;i<n;i++){
            cin>>x;
            BT=insert(BT,x);
        }
        for(int i=0;i<l;i++){
            Tree temp=NULL;
            for(int i=0;i<n;i++){
                cin>>x;
                temp=insert(temp,x);
            }
            judgeidentical(temp,BT)?cout<<"Yes"<<endl:cout<<"No"<<endl;
        }
    }
    return 0;
}


------------------------


题目16:
题目：堆中的路径 25 分难度：7-17
正文：
将一系列给定数字插入一个初始为空的小顶堆`H[]`。随后对任意给定的下标`i`，打印从`H[i]`到根结点的路径。

### 输入格式:

每组测试第1行包含2个正整数$N$和$M$(\le 1000$)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的$N$个要被插入一个初始为空的小顶堆的整数。最后一行给出$M$个下标。

### 输出格式:

对输入中给出的每个下标`i`，在一行中输出从`H[i]`到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。

### 输入样例:
```in
5 3
46 23 26 24 10
5 4 3
```

### 输出样例:
```out
24 23 10
46 23 10
26 10
```

答案：
#include <stdio.h>
#define MAX 1001	//堆在存储的时候根结点从1开始，于是这里是1001。 
#define MINH -10001
int nums[MAX];
int size=0;
void insert(int in){
	
	int i=++size;
	for(;in<nums[i/2];i/=2){
		nums[i]=nums[i/2];
	}
	nums[i]=in; 
}
int main(){
	 nums[0]=-10001;//哨兵 
	 int n,m,t;
	 scanf("%d %d", &n, &m);
	 
	 for(int i=0;i<n;++i){
	 	
	 	scanf("%d", &t);
	 	insert(t);
	 }

	 while(m--){
	 	scanf("%d",&t);
	 int   falg=1;
	 	while(t){
	 		if(falg){
	 			falg=0;
			 	printf("%d",nums[t]);
			 }else printf(" %d",nums[t]);
	 		t/=2;
		 }
		 printf("\n");
	 }
	return 0;
} 

------------------------


题目17:
题目：构造哈夫曼树 20 分难度：7-18
正文：
输入一些单词及其出现的频度，构造一棵哈夫曼树，输出哈夫曼编码的平均码长。

### 输入格式:

输入N，表示有N个单词，以下N行，每一行表示一个单词及其频度。

### 输出格式:

平均码长用浮点数类型表示，保留小数点后5位。

### 输入样例:

在这里给出一组输入。例如：

```in
11
The 1192
of 677
a 541
to 518
and 462
that 242
he 195
is 190
for 157
His 138
are 124
```

### 输出样例:

在这里给出相应的输出。例如：

```out
3.10437
```


答案：
import java.text.DecimalFormat;
import java.util.ArrayDeque;
import java.util.Scanner;

/**
 * JAVA中的对象类型本质上应该叫做 对象指针 类型。那么传统的对象类型呢？在JAVA里已经不见了踪影！
 * 既然没有了传统的对象类型，那么 对象指针变量 前面的*也就可以不要了。对象指针变量也就可以简称为对象变量了，
 * 反正也不会和其它概念混淆！ 所有的对象变量都是指针，没有非指针的对象变量，想不用指针都不行，这就是指针的泛化和强化。
 * 不叫指针了，就叫对象变量，这就是概念上的淡化和弱化。 没有了指针的加减运算，也没有了*、->等运算符，这是对指针的简单化。
 */
//测试时复制还是指针指向
//        Node node1=new Node();
//        Node node2=new Node();
//        node1.parent=node2;
//        if (node2.hashCode()==node1.parent.hashCode()){
//            System.out.println("是指向");
//        }else {
//            System.out.println("是复制");
//        }

    
public class Main {
    public static void main(String[] args) {
        //输入N，表示有N个单词，以下N行，每一行表示一个单词及其频度。
        Scanner scanner=new Scanner(System.in);
        int n=scanner.nextInt();
        Array array=new Array(n);
        for (int i=0;i<n;i++){
            Node node=new Node();
            node.data=scanner.next();
            node.frequency=scanner.nextInt();
            array.add(node);
        }
        System.out.println(new DecimalFormat(".00000").format(array.calculate(array.create())));

    }
    private static class Array{
        Node[] array;
        //此时数组中node的个数
        int current=0;
        public Array(int n) {
            array=new Node[2*n];
        }
        //向数组中加入结点
        public void add(Node ... nodes){
            if (nodes.length+current>array.length){
                System.out.println("数组溢出");
            }
            for (Node node:nodes){
                array[current++]=node;
            }
        }
        //找到两个最小频率的结点
        public Node[] findMin(){
            if (array.length<2){
                System.out.println("数组长度过短");
            }
            Node node1=null;
            Node node2=null;
            Node[] temp=new Node[2];
            for (int i=0;i<current;i++) {
                if (array[i].flag == false) {
                    if (node1 == null ) {
                        node1 = array[i];
                    } else if (node2 == null ) {
                        node2 = array[i];
                    } else if (node1.frequency > array[i].frequency||node2.frequency > array[i].frequency) {
                       if (node2.frequency>node1.frequency){
                           node2=array[i];
                       }else {
                           node1=array[i];
                       }
                    }
                }
            }

            temp[0]=node1;
            temp[1]=node2;
            return temp;
        }
        //建树
        public Node create(){
            for (int i=0;i<current;i++){
                Node[] temp=findMin();
                if (temp[0]==null&&temp[1]!=null){
                    return temp[1];
                }else if (temp[1]==null&&temp[0]!=null){
                    return temp[0];
                }else if (temp[1]!=null&&temp[0]!=null){
                    temp[0].flag=true;
                    temp[1].flag=true;
                    Node node=new Node(temp[0].frequency+temp[1].frequency);
                    node.lchild=temp[0];
                    node.rchild=temp[1];
                    add(node);
                }else {
                    System.out.println("数组中没数！！！");
                    return null;
                }
            }
            return null;
        }

        /**
         * 计算平均码长
         * @param root 根节点
         * @return 平均码长
         */
        public float calculate(Node root){
            float total=0;
            //总频率
            float count=0;
            ArrayDeque<Node> arrayDeque=new ArrayDeque<>();
            arrayDeque.push(root);
            root.floor=0;
            while (!arrayDeque.isEmpty()){
                Node temp=arrayDeque.poll();
                if (temp.isLeaf()){
                    total+=temp.floor*temp.frequency;
                    count+=temp.frequency;
                }
                if (temp.lchild!=null){
                    temp.lchild.floor=temp.floor+1;
                    arrayDeque.push(temp.lchild);
                }
                if (temp.rchild!=null){
                    temp.rchild.floor=temp.floor+1;
                    arrayDeque.push(temp.rchild);
                }
            }
            return total/count;

        }

    };
    //建立node结点类
    private static class Node{
        String data=null;
        int  frequency;
        Node lchild=null;
        Node rchild=null;
        //表示是否被遍历
        Boolean flag=false;
        //存储层数
        Integer floor=null;
        public Node() {
        }

        public Node(int frequency) {
            this.frequency = frequency;
        }

        /**
         * 判断是否是叶子结点
         * @return 是则返回true，不是则返回false
         */
        public boolean isLeaf(){
            if (lchild==null&&lchild==null){
                return true;
            }else return false;
        }
    }
}



------------------------


题目18:
题目：部落 25 分难度：7-19
正文：
在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。

### 输入格式：

输入在第一行给出一个正整数$N$（\le 10^4$），是已知小圈子的个数。随后$N$行，每行按下列格式给出一个小圈子里的人：

$K$ $P[1] $P[2] \cdots$ $P[K]

其中$K$是小圈子里的人数，$P[i]（$i=1, \cdots , K$）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过$10^4$。

之后一行给出一个非负整数$Q$（\le 10^4$），是查询次数。随后$Q$行，每行给出一对被查询的人的编号。


### 输出格式：

首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出`Y`，否则输出`N`。

### 输入样例：
```in
4
3 10 1 2
2 3 4
4 1 5 7 8
3 9 6 4
2
10 5
3 7
```

### 输出样例：
```out
10 2
Y
N
```

答案：
#include<iostream>
using namespace std;
#define MAX 10003

int size=0;
int n;
int people[MAX]={0};
int fu[MAX];

int qure(int son){
	if(son==fu[son])return son;
	
	return fu[son]=qure(fu[son]);
}
void join(int a,int b){
	int aa=qure(a);
	int bb=qure(b);
	if(aa!=bb){
		fu[aa]=bb;
		size++;
	}
}
int getpeople(){
	int res=0;
	for(int i=1;i<=MAX;++i){
		if(people[i]>0){
			res++;
		}
	}
	return res;
}
void init(){
	
	for(int i=0;i<MAX;++i){
		fu[i]=i;
	}
}

int main(){
	
	int m,t,q;
	cin>>n;
	init();
	for(int i=0;i<n;++i){
		cin>>m;
		q=-1;
		for(int j=0;j<m;++j){
			cin>>t;
			people[t]=1;
				if(q!=-1)
					join(q,t);
			q=t;
		}
	}
	cout<<getpeople()<<" ";
	int numss=0;
	for(int i=1;i<=getpeople();++i){
//		cout<<"fu["<<i<<"]="<<fu[i]<<endl;
		if(fu[i]==i){
			numss++;
		}
	}
	cout<<numss<<endl;
	cin>>n;
	int a,b;
	while(n--){
		cin>>a>>b;
		if(qure(a)==qure(b)){
			cout<<"Y\n";
		}else{
			cout<<"N\n";
		}
	}
	
	return 0;
} 

------------------------


题目19:
题目：分而治之 25 分难度：7-20
正文：
分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。

### 输入格式：

输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （\le$ 100）和随后的 K 行方案，每行按以下格式给出：

```
Np v[1] v[2] ... v[Np]
```

其中 `Np` 是该方案中计划攻下的城市数量，后面的系列 `v[i]` 是计划攻下的城市编号。

### 输出格式：

对每一套方案，如果可行就输出`YES`，否则输出`NO`。

### 输入样例：
```in
10 11
8 7
6 8
4 5
8 4
8 1
1 2
1 4
9 8
9 1
1 10
2 4
5
4 10 3 8 4
6 6 1 7 5 4 9
3 1 8 4
2 2 8
7 9 8 7 6 5 4 2
```

### 输出样例：
```out
NO
YES
YES
NO
NO
```


答案：
#include<iostream>
#include<string.h>
#include<vector>
#define MAX 10000+5
using namespace std;
vector<int> map[MAX];
int du[MAX] = { 0 };
int du2[MAX] = { 0 };
int main() {
	int n, m;
	cin >> n >> m;
	int a, b;
	while (m--) {
		cin >> a >> b;
		du[a]++;
		du[b]++;
		map[a].push_back(b);
		map[b].push_back(a);
	}
	int nn;
	cin >> nn;
	int t;
	while (nn--) {
		memcpy(du2, du, sizeof(du));
		cin >> m;
		while (m--) {
			cin >> t;
			du2[t] = 0;
			int sizemap = map[t].size();
			for (int i = 0; i < sizemap; ++i)
				du2[map[t][i]]--;
		}
		int falg = 1;
		for (int i = 1; i <= n; ++i) {
			if (du2[i] > 0)
				falg = 0;
		}
		if (falg)
			cout << "YES" << endl;
		else
			cout << "NO" << endl;
	}
	return 0;
}

------------------------


题目20:
题目：图着色问题 25 分难度：7-21
正文：
图着色问题是一个著名的NP完全问题。给定无向图$G = (V, E)，问可否用$K$种颜色为$V$中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？

但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。


### 输入格式：

输入在第一行给出3个整数$V$（$0 < V \le 500$）、$E$（\ge 0$）和$K$（$0 < K \le V$），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到$V$编号。随后$E$行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数$N$（\le 20$），是待检查的颜色分配方案的个数。随后$N$行，每行顺次给出$V$个顶点的颜色（第$i$个数字表示第$i$个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。

### 输出格式：

对每种颜色分配方案，如果是图着色问题的一个解则输出`Yes`，否则输出`No`，每句占一行。


### 输入样例：
```in
6 8 3
2 1
1 3
4 6
2 5
2 4
5 4
5 6
3 6
4
1 2 3 3 1 2
4 5 6 6 4 5
1 2 3 4 5 6
2 3 4 2 3 4
```

### 输出样例：
```out
Yes
Yes
No
No
```

答案：
#include<iostream>
#include<string.h>
#include<set>
using namespace std;
#define MAX 505
int map[MAX][MAX];
int vis[MAX];
int color[MAX];
int cnt=0;//颜色的个数

void iscan(int v){
	for(int i=0;i<v;++i){
		for(int j=0;j<v;++j){
			if(i!=j&&map[i][j]!=0&&color[i]==color[j]){
				cout<<"No\n";
				return;
				
			}
		}
	}
	cout<<"Yes\n";
}
int main(){
	int v,e,k;
	cin>>v>>e>>k;
	int a,b;
    set<int> se;
	for(int i=0;i<e;++i){
		cin>>a>>b;
		a--;
		b--;
		map[a][b]=map[b][a]=1;
	}

    int n;
	cin>>n;
	int t;
	while(n){
		n-=1;
        se.clear();//清除
		memset(vis,0,sizeof(vis));
		memset(color,0,sizeof(vis));
		
		for(int i=0;i<v;++i){
			cin>>t;
			se.insert(color[i]=t);
		}
		
		if(se.size()!=k){
            cout<<"No\n";
        }
		else{
			int falg=1;
			for(int xx=0;xx<v;++xx){
				for(int yy=0;yy<v;++yy){
					if(xx!=yy&&map[xx][yy]!=0&&color[xx]==color[yy]){
						falg=0;
						break;
					}
				}
			}
			if(falg==1){
				cout<<"Yes\n";
			}else{
                cout<<"No\n";
            }
        }
	}
	return 0;
} 

------------------------


题目21:
题目：深入虎穴 25 分难度：7-22
正文：
著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。

内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 ―― 请编程帮他找出距离入口最远的那扇门。

### 输入格式：

输入首先在一行中给出正整数 $N$（< 10^5$），是门的数量。最后 $N$ 行，第 $i$ 行（$1\le i \le N$）按以下格式描述编号为 $i$ 的那扇门背后能通向的门：

```
K D[1] D[2] ... D[K]
```
其中 `K` 是通道的数量，其后是每扇门的编号。

### 输出格式：

在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。

### 输入样例：
```in
13
3 2 3 4
2 5 6
1 7
1 8
1 9
0
2 11 10
1 13
0
0
1 12
0
0
```

### 输出样例：
```out
12
```


答案：
#include<iostream>
#include<queue>
#include<string.h>
#include<vector>
using namespace std;
#define MAX 100005
int vis[MAX];
vector<int> map[MAX];

int main(){
	int n;
	cin>>n;
	//记录入口，没有人通向它 
	int m,t;
	
	for(int i=1;i<=n;++i){
		vis[i]=1;
	}
	for(int i=1;i<=n;++i){
		cin>>m;
		for(int j=0;j<m;++j){
			cin>>t;
			vis[t]=0;
			map[i].push_back(t);
		//	map[t].push_back(i);
		}
	}
	


	int max=0;
	queue<int> q;
	
	int ru=-1;
	for(int i=1;i<=n;++i){
		if(vis[i]==1){
			ru=i;
			vis[i]=0; 
			break;
		}
	}
	q.push(ru);
	vis[ru]=1;
	int temp;
	
	while(!q.empty()){
		temp=q.front();
		q.pop();
	
		for(int i=0;i<map[temp].size();++i){
			if(!vis[map[temp][i]]){
				vis[map[temp][i]]=1;
				q.push(map[temp][i]);
				
			}
		}
	}
	cout<<temp<<endl;
	
	
	return 0;
} 

------------------------


题目22:
题目：公路村村通 30 分难度：7-23
正文：
现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。

### 输入格式:

输入数据包括城镇数目正整数$N$（\le 1000$）和候选道路数目$M$（\le 3N$）；随后的$M$行对应$M$条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到$N$编号。

### 输出格式:

输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出-1$，表示需要建设更多公路。

### 输入样例:
```in
6 15
1 2 5
1 3 3
1 4 7
1 5 4
1 6 2
2 3 4
2 4 6
2 5 2
2 6 6
3 4 6
3 5 1
3 6 1
4 5 10
4 6 8
5 6 3
```

### 输出样例:
```out
12
```

答案：
#include<iostream>
using namespace std;
#define INF 0x3f3f3f3f
int n,m;
int dic[1005]={0};
int map[1005][1005]={0};
int gets(){
	int res,cont,tmin,indmin;
	res=cont=0;
	for(int i=1;i<=n;++i){
		dic[i]=map[1][i];//默认初始为1号节点 ，即默认把1号放进铺设集合 
	} 
	
	for(int i=2;i<=n;++i){//一共执行n-1次最小值 才能把所有的点加入集合 
		tmin=INF;//最小值 
		for(int j=2;j<=n;++j){
			//find min
			if(dic[j]<tmin&&dic[j]!=0){
				tmin=dic[j];
				indmin=j;//下标 
			}
		}
		// min
		if(tmin!=INF){
			dic[indmin]=0;
			res+=tmin;
			cont++; 
		//修改  dic[min][j]  集合外到集合的距离 
			for(int j=2;j<=n;++j){
				if(map[indmin][j]<dic[j])
					dic[j]=map[indmin][j];
			}
		
		}
		
	}
	return cont==n-1?res:-1;//n个节点加入集合的次数一共为n-1次 
	
}

void init()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			map[i][j]=INF;
		}
	}
}
int main(){
	cin>>n>>m;
	init();
	int a,b,val;
	for(int i=0;i<m;++i){
		cin>>a>>b>>val;
		map[a][b]=map[b][a]=val;
	}	
	
	int res=gets();
	cout<<res<<endl;
	return 0;
} 

------------------------


题目23:
题目：最短路径 20 分难度：7-24
正文：
给定一个有N个顶点和E条边的无向图，顶点从0到N?1编号。请判断给定的两个顶点之间是否有路径存在。如果存在，给出最短路径长度。
这里定义顶点到自身的最短路径长度为0。
进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。

### 输入格式:

输入第1行给出2个整数N(0<N≤10)和E，分别是图的顶点数和边数。
随后E行，每行给出一条边的两个顶点。每行中的数字之间用1空格分隔。
最后一行给出两个顶点编号i，j（0≤i,j<N）,i和j之间用空格分隔。

### 输出格式:

如果i和j之间存在路径，则输出"The length of the shortest path between i and j is X."，X为最短路径长度，
否则输出"There is no path between i and j."。

### 输入样例1:



```in
7 6
0 1
2 3
1 4
0 2
1 3
5 6
0 3
```

### 输出样例1:



```out
The length of the shortest path between 0 and 3 is 2.
```
### 输入样例2:



```in
7 6
0 1
2 3
1 4
0 2
1 3
5 6
0 6
```

### 输出样例2:



```out
There is no path between 0 and 6.
```


答案：
#include<iostream>
#include<vector>
#include<string.h>
#include<queue> 
using namespace std;
int n,e,b1,b2;
int vis[50]={0};
int len[50]={0};
vector<vector<int> > v;

int bfs(int bs,int be){
 	if(bs==be){
         return 0;
     }
    queue<int> q;
	
	q.push(bs);
	vis[bs]=1;
	len[bs]=0;
    int t=0;
    int size=0;
	while(!q.empty()){
		 t=q.front();q.pop();
		size=v[t].size();
		for(int i=0;i<size;++i){
			if(!vis[v[t][i]]){
				q.push(v[t][i]);
				len[v[t][i]]=len[t]+1;
				vis[v[t][i]]=1;
			}
			if(v[t][i]==be){
				return len[v[t][i]];
			}
		}
	}
	//if(vis[be]){
//		return len[be];
//	}
	
	return -1;
}

int main(){
	ios::sync_with_stdio(false);
	cin>>n>>e;
	v.resize(11);//为v 分配大小，即11个数组 
	for(int i=0;i<e;++i){
        v[i].resize(11);//为每个v[i]分配大小 
		cin>>b1>>b2;
		v[b1].push_back(b2);
		v[b2].push_back(b1);
	}
	cin>>b1>>b2;
	int len=bfs(b1,b2);
	if(len!=-1){
		cout<<"The length of the shortest path between "<<b1<<" and "<<b2<<" is "<<len<<"."<<endl;
	}else{
		cout<<"There is no path between "<<b1<<" and "<<b2<<"."<<endl;
	}
	return 0;
} 

------------------------


题目24:
题目：旅游规划 25 分难度：7-25
正文：
有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。

### 输入格式:

输入说明：输入数据的第1行给出4个正整数$N$、$M$、$S$、$D$，其中$N$（$2\le N\le 500$）是城市的个数，顺便假设城市的编号为0~($N-1$)；$M$是高速公路的条数；$S$是出发地的城市编号；$D$是目的地的城市编号。随后的$M$行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。

### 输出格式:

在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。

### 输入样例:
```in
4 5 0 3
0 1 1 20
1 3 2 30
0 3 4 10
0 2 2 20
2 3 1 20
```

### 输出样例:
```out
3 40
```

答案：
#include<iostream>
#include<queue>
 
#include<string.h>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=600;

int map[N][N];
int primap[N][N];
int vis[N];
int tlen[N];
int tprice[N];
int dist[N];
int minlen,minprice;
int dijkstra(int st,int len,int map[][N],int end,int& Price){
	int vis[len];
	int dic[len];
	const int INF=0x3f3f3f3f;
	for(int i=0;i<len;++i){
		vis[i]=0;
		dic[i]=INF;
	}
	Price=INF;
	dic[st]=0;
	tprice[st]=0;
	int t;
	int tnum;
	while(1){
		t=-1;
		for(int i=0;i<len;++i){
			if(!vis[i]&&(t==-1|| ( dic[i]<dic[t] || (dic[i]==dic[t]&&tprice[i]<tprice[t])  )   )){
				t=i;
			}
		}
		//最小 t
		for(int i=0;i<len;++i){
			tnum=dic[t]+map[t][i];
			if(tnum<dic[i]&&!vis[i]){
				dic[i]=tnum;
				tprice[i]=tprice[t]+primap[t][i];
			}else if(tnum==dic[i]&&!vis[i]&&tprice[i]>tprice[t]+primap[t][i]){
				dic[i]=tnum;
				tprice[i]=tprice[t]+primap[t][i];
			}
		}
		if(t==-1){
			break;
		}
		
		vis[t]=1;
	}
	
	if(dic[end]==INF)return -1;
	
	Price=tprice[end];
	return dic[end];
}
int main(){
	ios::sync_with_stdio(false);
	memset(primap,0,sizeof(primap));
	memset(vis,0,sizeof(vis));
	memset(tlen,0,sizeof(tlen));
	memset(tprice,0,sizeof(tprice));
	int n,m,s,d;
	int st,ed,len,price;
	
	minlen=minprice=999;
	
	cin>>n>>m>>s>>d;
	
	for(int i=0;i<n;++i){
		for(int j=0;j<n;++j){
			map[i][j]=map[j][i]=INF;
		}
	} 
	for(int i=1;i<=m;++i){
		cin>>st>>ed>>len>>price;
		map[st][ed]=map[ed][st]=len;
		primap[st][ed]=primap[ed][st]=price;
	}
	
	int minlen=dijkstra(s,n,map,d,minprice);
		
	cout<<minlen<<" "<<minprice<<endl;
	return 0;
}

------------------------


题目25:
题目：冒泡法排序 20 分难度：7-116
正文：
将$N$个整数按从小到大排序的冒泡排序法是这样工作的：从头到尾比较相邻两个元素，如果前面的元素大于其紧随的后面元素，则交换它们。通过一遍扫描，则最后一个元素必定是最大的元素。然后用同样的方法对前$N-1$个元素进行第二遍扫描。依此类推，最后只需处理两个元素，就完成了对$N$个数的排序。

本题要求对任意给定的$K$（<N$），输出扫描完第$K$遍后的中间结果数列。

### 输入格式：

输入在第1行中给出$N$和$K$（$1\le K<N\le 100$），在第2行中给出$N$个待排序的整数，数字间以空格分隔。

### 输出格式：

在一行中输出冒泡排序法扫描完第$K$遍后的中间结果数列，数字间以空格分隔，但末尾不得有多余空格。

### 输入样例：
```in
6 2
2 3 5 1 6 4
```

### 输出样例：
```out
2 1 3 4 5 6
```

答案：
#include<iostream>
using namespace std;

int maopao(int list[],int n,int k){
	for(int i=0;i<k;++i){
		for(int j=0;j<n-1-i;++j){
			if(list[j]>list[j+1]){
				int t=list[j];
				list[j]=list[j+1];
				list[j+1]=t;
			}
		}
	}
		cout<<list[0];
		for(int i=1;i<n;++i){
			cout<<" "<<list[i]; 
		}
		cout<<endl;
}
int list[105];
int main(){
	int n,k;
	cin>>n>>k;
	for(int i=0;i<n;++i){
		cin>>list[i];
	}
	maopao(list,n,k);
	return 0;
} 

------------------------


题目26:
题目：英文单词排序 25 分难度：7-113
正文：
本题要求编写程序，输入若干英文单词，对这些单词按长度从小到大排序后输出。如果长度相同，按照输入的顺序不变。

### 输入格式：

输入为若干英文单词，每行一个，以`#`作为输入结束标志。其中英文单词总数不超过20个，英文单词为长度小于10的仅由小写英文字母组成的字符串。

### 输出格式：

输出为排序后的结果，每个单词后面都额外输出一个空格。

### 输入样例：
```in
blue
red
yellow
green
purple
#
```

### 输出样例：
```out
red blue green yellow purple 
```

答案：

#include<iostream>
#include<string>
#include<algorithm>
using namespace std;

void maopao(string list[],int n){
	for(int i=0;i<n;++i){
		for(int j=0;j<n-1-i;++j){
			if(list[j].length()>list[j+1].length()){
				string t=list[j];
				list[j]=list[j+1];
				list[j+1]=t;
			}
		}
	}
	
	for(int i=0;i<n;++i){
		cout<<list[i]<<" "; 
	}
	cout<<endl;
}
void charu(string list[],int n){
    int i,j;
    string t;
    for(i=1;i<n;++i){
        t=list[i];//对比对象
        for( j=i;j>0&&list[j-1].length()>t.length();--j){
            list[j]=list[j-1];
        }
        list[j]=t;//相应位置插入
    }
    for(int i=0;i<n;++i){
		cout<<list[i]<<" "; 
	}
	cout<<endl;
}

template<class T>
int mycompare( T& a, T& b){
	return a.length()<=b.length();
}
int comp2(string& a,string& b){
	return a.length()<b.length();
}
template<class T>
void charu2(int n,T* src){
	int j;
	T t;
	for(int i=1;i<n;++i){
		t=src[i];
		for(j=i;j>0&&mycompare(src[j-1],t);--j){
			src[j]=src[j-1];
		}
		src[j]=t;
	} 
}
void myQuitSort(string *src,int l,int r){
	//cout<<"l="<<l<<" r="<<r<<endl;
	if(l>=r)return;
	int i=l-1;
	int j=r+1;
	string x=src[ (l+r) >> 1 ];//(i+j)/2
	string t;
	int ind=(l+r)/2;
	while(i<j){
		do {
			i++;
		}while(src[i].length()<x.length() || ( src[i].length()==x.length()&&i<ind ) );//&&x!=src[i]
		do{
			j--;
		}while(x.length()<src[j].length() || (x.length()==src[j].length()&&j>ind )  );// && x!=src[j]
		
		if(i<j){
			t=src[i];
			src[i]=src[j];
			src[j]=t;
            if(src[i]==x)x=src[j];
            if(src[j]==x)x=src[i];
            
        //    cout<<"x="<<x<<endl;
		}else{
			// cout<<"i="<<i<<" j="<<j<<endl;
			 break;
		}
	}
	myQuitSort(src,l,j);//i!=j
	myQuitSort(src,j+1,r);
} 
string list[105];
int main(){
	int i=0;
	string str;
	for(;;){
		cin>>str;
		if(str=="#")
			break;
		list[i++]=str;
		
	}
	myQuitSort(list,0,i-1);
    for(int j=0;j<i;++j){
		cout<<list[j]<<" "; 
	}
	cout<<endl;
	return 0;
} 

------------------------


题目27:
题目：学生成绩排序 20 分难度：7-30
正文：
给出一组学生名单（姓名和成绩），请输出按成绩**从大到小**排序后的结果（名次和姓名）。成绩相同的人拥有相同的名次，且按姓名的字典序**从小到大**排列。题目保证学生姓名没有重复。

### 输入格式:

第一行给出不大于10000的整数N。
接下来N行，每行给出学生姓名和成绩，以空格分隔。学生姓名不超过20个字符。

### 输出格式:

共输出N行，每行包含对应的学生排名和姓名，以空格分隔。

### 输入样例:

```in
7
KongDezhen 94
FuTaotao 93
HuYu 94
XuJiecen 94
WuSuqi 96
ChenDa 93
HuNianbo 95
```

### 输出样例:

```out
1 WuSuqi
2 HuNianbo
3 HuYu
3 KongDezhen
3 XuJiecen
6 ChenDa
6 FuTaotao
```


答案：
#include<iostream>
#include<string>
using namespace std;

void maopao(string* list,int* scores,int n){
    string t;
    int tt;
	for(int i=0;i<n;++i){
		for(int j=0;j<n-1-i;++j){
			if(scores[j]<scores[j+1]||  (scores[j]==scores[j+1]&&list[j]>list[j+1]  )){
				 t=list[j];
				list[j]=list[j+1];
				list[j+1]=t;
				
				 tt=scores[j];
				scores[j]=scores[j+1];
				scores[j+1]=tt;
			}
		}
	}
	
     tt=0;
	for(int i=0;i<n;++i){
		if(scores[i]==scores[i-1]&&i>0){
//			printf("%d  %s",tt,list+i);
			cout<<tt<<" "<<list[i]<<endl; 
		}
		else{
			tt=i+1;
		//	printf("%d  %s",i+1,list+i);
			cout<<i+1<<" "<<list[i]<<endl; 
		}
			
	}
}

void charru(string* list,int* scores,int n){
    string t;
    int tt;
    int j;
	for(int i=1;i<n;++i){
        t=list[i];
        tt=scores[i];
		for( j=i;j>0&&(scores[j-1]<tt|| (scores[j-1]==tt&&list[j-1]>t  ));--j){
            list[j]=list[j-1];
            scores[j]=scores[j-1];
		
		}
        list[j]=t;
        scores[j]=tt;
	}
	
     tt=0;
	for(int i=0;i<n;++i){
		if(scores[i]==scores[i-1]&&i>0){
//			printf("%d  %s",tt,list+i);
			cout<<tt<<" "<<list[i]<<endl; 
		}
		else{
			tt=i+1;
		//	printf("%d  %s",i+1,list+i);
			cout<<i+1<<" "<<list[i]<<endl; 
		}
			
	}
}
string lists[10005];
int sore[10005];
int main(){
	int n,sco;
	cin>>n;
//	scanf("%d",&n);
	string str;
	for(int i=0;i<n;++i){
		cin>>lists[i]>>sore[i];
//		scanf("%s %d",&lists[i],&sore[i]);
	}
	charru(lists,sore,n);
	return 0;
} 

------------------------


题目28:
题目：抢红包 25 分难度：7-114
正文：
没有人没抢过红包吧…… 这里给出$N$个人之间互相发红包、抢红包的记录，请你统计一下他们抢红包的收获。

### 输入格式：

输入第一行给出一个正整数$N$（\le 10^4$），即参与发红包和抢红包的总人数，则这些人从1到$N$编号。随后$N$行，第$i$行给出编号为$i$的人发红包的记录，格式如下：

$K\quad N_1\quad P_1\quad \cdots\quad N_K\quad P_K$

其中$K$（$0 \le K \le 20$）是发出去的红包个数，$N_i$是抢到红包的人的编号，$P_i$（>0$）是其抢到的红包金额（以分为单位）。注意：对于同一个人发出的红包，每人最多只能抢1次，不能重复抢。

### 输出格式：

按照收入金额从高到低的递减顺序输出每个人的编号和收入金额（以元为单位，输出小数点后2位）。每个人的信息占一行，两数字间有1个空格。如果收入金额有并列，则按抢到红包的个数递减输出；如果还有并列，则按个人编号递增输出。

### 输入样例：
```in
10
3 2 22 10 58 8 125
5 1 345 3 211 5 233 7 13 8 101
1 7 8800
2 1 1000 2 1000
2 4 250 10 320
6 5 11 9 22 8 33 7 44 10 55 4 2
1 3 8800
2 1 23 2 123
1 8 250
4 2 121 4 516 7 112 9 10
```

### 输出样例：
```out
1 11.63
2 3.63
8 3.63
3 2.11
7 1.69
6 -1.67
9 -2.18
10 -3.26
5 -3.26
4 -12.32
```

答案：
#include<cstdio>
#include<iostream> 
#include<cstring>
#include<algorithm>
using namespace std;
 
const int maxn=100010;
 
struct node{
	
	int id;
	int cnt;
	int money;
 	
	node(){
		
		id=0;
		cnt=0;
		money=0;
	}
}; 
 
bool cmp(node a,node b){
	
	if(a.money!=b.money)
	  return a.money>b.money;
	  
	if(a.cnt!=b.cnt)
	  return a.cnt>b.cnt;
	
	return a.id<b.id;  
	
}
 
int main(){
	
	node nodes[maxn];
     int n;
     cin>>n;
     
     for(int i=1;i<=n;i++){
	
     	int num,sum=0;
     	
     	cin>>num;
     	while(num--){
     		
     		int a,b;
     		cin>>a>>b;
     		
     		nodes[a].money+=b;
     		nodes[a].cnt++;
 			sum+=b;
		 }
		 
		 nodes[i].money-=sum;
  		 nodes[i].id=i;
	 }
     
     sort(nodes+1,nodes+n+1,cmp);
     
     for(int i=1;i<=n;i++){
     	
     	cout<<nodes[i].id<<" ";
     	
     	 double ans=nodes[i].money/100.0;
     	 
     	printf("%.2f\n",ans);
     	
	 }
  
} 

------------------------


题目29:
题目：统计工龄 20 分难度：7-115
正文：
给定公司$N$名员工的工龄，要求按工龄增序输出每个工龄段有多少员工。

### 输入格式:

输入首先给出正整数$N$（\le 10^5$），即员工总人数；随后给出$N$个整数，即每个员工的工龄，范围在[0, 50]。

### 输出格式:

按工龄的递增顺序输出每个工龄的员工个数，格式为：“工龄:人数”。每项占一行。如果人数为0则不输出该项。

### 输入样例:
```in
8
10 2 0 5 7 2 5 2
```

### 输出样例:
```out
0:1
2:3
5:2
7:1
10:1
```

答案：
#include<iostream>
using namespace std;
void swap(int &a,int &b){
	int t=a; a=b; b=t;
}
void show_result(int A[],int N){
	int cnt=0,age=A[0];
 ? for(int i=0;i<N;i++){
? ? ? ?if(A[i]==age) cnt++;
? ? ? ?else {cout<<age<<":"<<cnt<<endl; age=A[i]; cnt=1;}
	}
	cout<<age<<":"<<cnt<<endl;
}
void Bubble_sort(int A[],int N){//冒泡排序法?
	for(int i=1;i<=N-1;i++){
		int flag=0;
		for(int j=0;j<=N-1-i;j++)
		if(A[j]>A[j+1]) {flag=1; swap(A[j],A[j+1]);}
		if(flag==0) break;	
	}
}
void Insertion_sort(int A[],int N){//插入排序法?
? ? int i,j;
	for(i=1;i<N;i++){
		int temp=A[i];
		for(j=i;j>0;j--){
			if(A[j-1]>temp) A[j]=A[j-1];
			else break;
		}
		A[j]=temp;
	}
}
void percdown(int A[],int N,int i){//最大堆下滤?
	int parent,child,temp=A[i];
	for(parent=i;2*parent+1<=N-1;parent=child){
		child=2*parent+1;?
		if(child<N-1&&A[child+1]>A[child]) child++;?
		if(temp<A[child]) A[parent]=A[child];
		else break;
	}
	A[parent]=temp;
}
void buildheap(int A[],int N){//建立最大堆
? ? ?for(int i=(N-1)/2;i>=0;i--){
? ? ?	percdown(A,N,i);
	 }?
}
void heap_sort(int A[],int N){//堆排序
? ? ?buildheap(A,N);
? ? ?int size=N;
	 for(int i=1;i<=N-1;i++){
	 	 swap(A[0],A[size-1]);
	 	 percdown(A,--size,0);
	 }
}?
void shell_sort(int A[],int N){//Sdegewick增量序列的希尔排序?
	int IncrementSequence_Sedgewick[]={0,
? ? 1,5,19,41,109,209,505,929,
? ? 2161,3905,8929,16001,36289,64769,146305,260609,
? ? 587521,1045505,2354689,4188161,9427969,16764929,37730305,67084289,
? ? 150958081,268386305,603906049,1073643521};
? ? int i=1,len,j,k;
? ? while(IncrementSequence_Sedgewick[++i]<=N){}
? ? for(i=i-1;i>=1;i--){
? ? 	len=IncrementSequence_Sedgewick[i];?
		for(j=len;j<N;j++){
? ? 	int temp=A[j];
? ? 	for(k=j;k>=len;k-=len)
		{
? ? ? ? if(temp<A[k-len]) swap(A[k],A[k-len]);
		else break;}
? ? ? ? A[k]=temp;
	}
}
}
void Merge(int A[],int l,int r,int rend,int temp[]){
	int lend=r-1,n=rend-l+1,cnt=l;
	while(l<=lend&&r<=rend){
		if(A[l]<A[r]) temp[cnt++]=A[l++];
		else temp[cnt++]=A[r++];
	}
	while(l<=lend) temp[cnt++]=A[l++];
	while(r<=rend) temp[cnt++]=A[r++];
	for(int i=0;i<n;i++)
	A[rend]=temp[rend--];
}
void Msort(int A[],int l,int rend,int temp[]){
	int center;
	if(l<rend){
	? ? center=(l+rend)/2;
		Msort(A,l,center,temp);
		Msort(A,center+1,rend,temp);
		Merge(A,l,center+1,rend,temp);
	}
}
void Merge_sort(int A[],int N){//归并排序（递归）?
	int *temp;
	temp=(int*)malloc(N*sizeof(int));
	if(temp!=NULL){
		Msort(A,0,N-1,temp);
		free(temp);
	}
	else cout<<"there is no enough space!"<<endl;
}?
void Merge1(int A[],int l,int r,int rend,int temp[]){
	int lend=r-1,n=rend-l+1,cnt=l;
	while(l<=lend&&r<=rend){
		if(A[l]<A[r]) temp[cnt++]=A[l++];
		else temp[cnt++]=A[r++];
	}
	while(l<=lend) temp[cnt++]=A[l++];
	while(r<=rend) temp[cnt++]=A[r++];
}
void Merge_pass(int A[],int N,int len,int temp[]){
	int i;
	for(i=0;i<N-1-2*len;i+=2*len)
	Merge1(A,i,i+len,i+2*len-1,temp);
	if(i+len<N) Merge1(A,i,i+len,N-1,temp);
	else?
	for(int j=i;j<N;j++) temp[j]=A[j];
}?
void Merge_sort2(int A[],int N){//（非递归）归并排序?
	int *temp;
	temp=(int*)malloc(N*sizeof(int));
	if(temp!=NULL){
	int len=1;
	while(len<N){
		Merge_pass(A,N,len,temp);
		len*=2;
		Merge_pass(temp,N,len,A);
		len*=2;?
	}
	free(temp);	
	}
	else cout<<"there is no enough space !"<<endl;
}?
int getpivot(int A[],int l,int r){//获得pivot?
	int m=(l+r)/2;
	if(A[m]<A[l]) swap(A[m],A[l]);
	if(A[r]<A[l]) swap(A[r],A[l]);
	if(A[r]<A[m]) swap(A[r],A[m]);
	swap(A[m],A[r-1]);
	return A[r-1];
}
void Qsort(int A[],int l,int r){//快速排序递归核心算法?
	int pivot,i,j,cutoff=1000;
	if(r-l>=cutoff){
		int pivot=getpivot(A,l,r);
		i=l; j=r-1;
		while(1){
			while(A[++i]<pivot) {}
			while(A[--j]>pivot) {}
			if(i<j) swap(A[i],A[j]);
			else break;
		}
		swap(A[r-1],A[i]);
		Qsort(A,l,i-1);
		Qsort(A,i+1,r);
	}
	else Insertion_sort(A+l,r-l+1);
}
void Quick_sort(int A[],int N){// 快速排序?
	Qsort(A,0,N-1);?
}?
int main(){
	int N; cin>>N;
	int A[N];
	for(int i=0;i<N;i++)
	cin>>A[i];
	//Bubble_sort(A,N);
	//Insertion_sort(A,N);
	//heap_sort(A,N);
	//shell_sort(A,N);?
	//Merge_sort2(A,N);
	Quick_sort(A,N);?
? ? show_result(A,N);
	return 0;
}?

------------------------


题目30:
题目：点赞狂魔 25 分难度：7-113
正文：
微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。

### 输入格式：

输入在第一行给出一个正整数$N$（\le 100$），是待统计的用户数。随后$N$行，每行列出一位用户的点赞标签。格式为“`Name` $K$ $F_1 \cdots F_K$”，其中`Name`是不超过8个英文小写字母的非空用户名，$1\le K\le 1000$，$F_i$（$i=1, \cdots , K$）是特性标签的编号，我们将所有特性标签从 1 到 $10^7$ 编号。数字间以空格分隔。

### 输出格式：

统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用`-`补齐缺失，例如`mike jenny -`就表示只有2人。

### 输入样例：
```in
5
bob 11 101 102 103 104 105 106 107 108 108 107 107
peter 8 1 2 3 4 3 2 5 1
chris 12 1 2 3 4 5 6 7 8 9 1 2 3
john 10 8 7 6 5 4 3 2 1 7 5
jack 9 6 7 8 9 10 11 12 13 14
```

### 输出样例：
```out
jack chris john
```

答案：
#include <cstdio>
#include <string.h>
#include <string>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <set>
using namespace std;
const int maxen=1010;
struct edge{
    char name[30];
    int num;
    int sum;
}node[maxen];
bool cmp(edge x,edge y){
    if(x.sum==y.sum)
    return x.num<y.num;
    return x.sum>y.sum;
}
int main(void){
     int n,k,u,count=0;
     char a;
     memset(node,0,sizeof(0));
     scanf("%d",&n);
     for(int i=1;i<=n;++i)
     {
     set<int> st; 
     scanf("%s",node[i].name);
     scanf("%d",&k);
     node[i].num=k;
     for(int j=1;j<=k;++j)
       {
        scanf("%d",&u);
        st.insert(u);
       }
         node[i].sum=st.size();
      }
      sort(node+1,node+1+n,cmp);
      if(n==1){
      printf("%s - -\n",node[1].name);
      }
      else if(n==2)
      {
      printf("%s %s -\n",node[1].name,node[2].name);
      }
      else
      {
      for(int i=1;i<=3;++i){
      if(i==1)
      printf("%s",node[i].name);
      else
      printf(" %s",node[i].name);
      }
          printf("\n");
      }
    return 0;
}

------------------------


题目31:
题目：银行业务队列简单模拟 100 分难度：7-119
正文：
设某银行有A、B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍 ―― 即当A窗口每处理完2个顾客时，B窗口处理完1个顾客。给定到达银行的顾客序列，请按业务完成的顺序输出顾客序列。假定不考虑顾客先后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口顾客优先输出。

### 输入格式:

输入为一行正整数，其中第1个数字N(\le$$1000)为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。

### 输出格式:

按业务处理完成的顺序输出顾客的编号。数字间以空格分隔，但最后一个编号后不能有多余的空格。

### 输入样例:
```in
8 2 1 3 9 4 11 13 15
```

### 输出样例:
```out
1 3 2 9 11 4 13 15
```

答案：
#include<iostream>
#include<queue>
#include<cstdio>
#include<algorithm>

using namespace std;

int main() {
	queue<int> A,B;
	int N; 
	int i=0;//用于判断第一个数据，是否有空格
	cin>>N;
	if(N<0)
		return 0;
	while(N--) {
		int m;
		cin>>m;
		if(m%2==1)
			A.push(m);
		else
			B.push(m);
	}
	while(!A.empty()) {
		int cot=2;
		while(cot--&&!A.empty()) {
			if(i++)
				cout<<" ";
			cout<<A.front();
			A.pop();
		}

		if(!B.empty()) {
			if(i++)
				cout<<" ";
			cout<<B.front();
			B.pop();
		}
	}
	while(!B.empty()) {
		if(i++)
			cout<<" ";
		cout<<B.front();
		B.pop();
	}
	return 0;
}


------------------------


题目32:
题目：列出叶结点 100 分难度：7-120
正文：
对于给定的二叉树，本题要求你按从上到下、从左到右的顺序输出其所有叶节点。

### 输入格式：

首先第一行给出一个正整数 $N$（\le 10$），为树中结点总数。树中的结点从 0 到 $N-1$ 编号。随后 $N$ 行，每行给出一个对应结点左右孩子的编号。如果某个孩子不存在，则在对应位置给出 "-"。编号间以 1 个空格分隔。

### 输出格式：

在一行中按规定顺序输出叶节点的编号。编号间以 1 个空格分隔，行首尾不得有多余空格。

### 输入样例：
```in
8
1 -
- -
0 -
2 7
- -
- -
5 -
4 6
```

### 输出样例：
```out
4 1 5
```


答案：
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<map>
#include<vector>
using namespace std;
struct node{
	char Left,Right;
}p[15];
int Root[15];
vector<int> Leaf[15];
void func(int s,int cur){
	if(p[s].Left=='-'&&p[s].Right=='-'){
		Leaf[cur].push_back(s);
		return;
	}
	if(p[s].Left!='-') func(p[s].Left-'0',cur+1);
	if(p[s].Right!='-') func(p[s].Right-'0',cur+1);
}
int main() {
	int n;
	memset(Root,0,sizeof Root);
	cin>>n;//怎么老是忘记输入n, 汗(⊙n⊙)b 
	for(int i=0;i<n;i++){
		cin>>p[i].Left>>p[i].Right;
		Root[p[i].Left-'0']=Root[p[i].Right-'0']=1;//能成为别人左右节点的节点必然不是根节点 
	}
	int rt;//记录根节点下标 
	for(int i=0;i<n;i++){
		if(!Root[i]){
			rt=i;
			break;
		}
	}
	func(rt,1);//将叶节点储存 
	int f=0;
	for(int i=1;i<=n;i++){ 
		for(int j=0;j<Leaf[i].size();j++){
			if(f) cout<<' ';
			else f=1;
			cout<<Leaf[i][j];
		}
	}
	cout<<endl;
	return 0;
}

------------------------


题目33:
题目：地下迷宫探索 30 分难度：7-121
正文：
地道战是在抗日战争时期，在华北平原上抗日军民利用地道打击日本侵略者的作战方式。地道网是房连房、街连街、村连村的地下工事，如下图所示。


![](~/52)

我们在回顾前辈们艰苦卓绝的战争生活的同时，真心钦佩他们的聪明才智。在现在和平发展的年代，对多数人来说，探索地下通道或许只是一种娱乐或者益智的游戏。本实验案例以探索地下通道迷宫作为内容。

假设有一个地下通道迷宫，它的通道都是直的，而通道所有交叉点（包括通道的端点）上都有一盏灯和一个开关。请问你如何从某个起点开始在迷宫中点亮所有的灯并回到起点？


![](~/53)

### 输入格式:

输入第一行给出三个正整数，分别表示地下迷宫的节点数$N$（$1<N\le 1000$，表示通道所有交叉点和端点）、边数$M$（\le 3000$，表示通道数）和探索起始节点编号$S$（节点从1到$N$编号）。随后的$M$行对应$M$条边（通道），每行给出一对正整数，分别是该条边直接连通的两个节点的编号。

### 输出格式:

若可以点亮所有节点的灯，则输出从$S$开始并以$S$结束的包含所有节点的序列，序列中相邻的节点一定有边（通道）；否则虽然不能点亮所有节点的灯，但还是输出点亮部分灯的节点序列，最后输出0，此时表示迷宫不是连通图。

由于深度优先遍历的节点序列是不唯一的，为了使得输出具有唯一的结果，我们约定以节点小编号优先的次序访问（点灯）。在点亮所有可以点亮的灯后，以原路返回的方式回到起点。

### 输入样例1:
```in
6 8 1
1 2
2 3
3 4
4 5
5 6
6 4
3 6
1 5
```

### 输出样例1:
```out
1 2 3 4 5 6 5 4 3 2 1
```

### 输入样例2:
```
6 6 6
1 2
1 3
2 3
5 4
6 5
6 4
```

### 输出样例2:
```
6 4 5 4 6 0
```

答案：
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int a[N][N],vis[N],tot,path[N+N],n,m,s;
void dfs(int x){
    for(int i=1;i<=n;i++)
    {
        if(a[x][i]&&!vis[i])
        {
            vis[i]=1;
            path[tot++]=i;
            dfs(i);
            path[tot++]=x;
        }
    }
}
int main()
{
    cin>>n>>m>>s;
    for(int i=0,u,v;i<m;i++)
        cin>>u>>v,a[u][v]=a[v][u]=1;
    path[tot++]=s,vis[s]=1;
    dfs(s);
    printf("%d",path[0]);
    for(int i=1;i<tot;i++)
        printf(" %d",path[i]);
    int f=0;
    for(int i=1;i<=n;i++)if(!vis[i])f=1;
    if(f)printf(" 0");
}


------------------------


题目34:
题目：逆序数 15 分难度：7-34
正文：
给出一个长度为n的数列，你每一次可以随意交换其中两个相邻数字的位置。问你至少交换几次，才能使得这个数列是个单调递增数列。

### 输入格式:

第一行输入一个n，第二行输入n个数

### 输出格式:

输出逆序数

### 输入样例:

在这里给出一组输入。例如：

```in
5
9 1 0 5 4 
```

### 输出样例:

在这里给出相应的输出。例如：

```out
6
```


答案：
#include<iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    int num[n+4];
    for(int i=0;i<n;++i){
        cin>>num[i];
    }
    int sum=0;
    for(int i=0;i<n-1;++i){
        for(int j=i+1;j<n;++j){
            if(num[i]>=num[j])sum++;
        }
    }
    cout<<sum<<endl;
    return 0;
}

------------------------


题目35:
题目：整型关键字的散列映射 25 分难度：7-35
正文：
给定一系列整型关键字和素数$P$，用除留余数法定义的散列函数$H(Key) = Key % P$将关键字映射到长度为$P$的散列表中。用线性探测法解决冲突。

### 输入格式:

输入第一行首先给出两个正整数$N$（\le 1000$）和$P$（\ge N$的最小素数），分别为待插入的关键字总数、以及散列表的长度。第二行给出$N$个整型关键字。数字间以空格分隔。

### 输出格式:

在一行内输出每个整型关键字在散列表中的位置。数字间以空格分隔，但行末尾不得有多余空格。

### 输入样例:
```in
4 5
24 15 61 88
```

### 输出样例:
```out
4 0 1 3
```

答案：
#include<iostream>
using namespace std;
int num[10005];
int main(){
    int a,b,n;
    cin>>n>>b;
    for(int i=0;i<n;i++){
        cin>>a;
        int count=0;
        while(num[(a+count)%b]!=a&&num[(a+count)%b]!=0)count++;
        num[(a+count)%b]=a;
        if(i>0)cout<<" ";//空格格式
        cout<<(a+count)%b;
    }
    return 0;
}

------------------------



题目：1重载函数的参数列表必须不相同。 答案：FALSE

题目：2int i; int &ri=i；对于这条语句，ri和i这两个变量代表的是同一个存储空间。   答案：TRUE

题目：3使用new运算符开辟存储空间后，不必使用delete运算符撤销相应的空间。   答案：FALSE

题目：4结构体成员的类型必须是基本数据类型。  答案：FALSE

题目：5结构是变量的集合，可以按照对基本数据类型的操作方法单独使用其成员变量。   答案：TRUE

题目：6在定义嵌套的结构类型时，必须先定义成员的结构类型，再定义主结构类型。   答案：FALSE

题目：7结构数组是结构与数组的结合体，与普通数组的不同之处在于每个数组元素都是一个结构类型的数据，包括多个成员项。   答案：TRUE

题目：8C++程序中，类的构造函数名与类名相同。   答案：TRUE

题目：9C++程序中，一个类的构造函数可以被重载。   答案：TRUE

题目：10C++程序中，一个类的析构函数可以被重载。   答案：FALSE

题目：11析构函数的作用主要是释放对象占用的资源。   答案：TRUE

题目：12构造函数可以通过对象多次调用。   答案：FALSE

题目：13有下面两种定义：  
```
struct stu{
	char name[8];		
	int age;	
	char sex;		
	double height;	
}; 
```
```
class stu{
public:
	char name[8];
	int age;
	char sex;
	double height;
}; 
```
它们的含义是完全等价的，都包含了相同的数据项，只不过是两种不同的类型。
 答案：TRUE

题目：14在定义对象数组时，可以直接进行初始化，也可以通过赋值语句实现赋值。   答案：TRUE

题目：15利用赋值语句对数组元素进行赋值时，系统先调用有参构造函数创建无名对象，并将其值赋给相应对象数组元素，然后再将无名对象释放,释放时调用析构函数。   答案：TRUE

题目：16this 指针是一个系统预定义的特殊指针,指向当前正在操作的对象。   答案：TRUE

题目：17静态成员的特点是不管这个类创建了多少个对象,其静态成员在内存中只保留一份副本,这个副本为该类的所有对象共享,或者说静态成员为类所有。   答案：TRUE

题目：18静态数据成员不能在类中初始化，使用时需要在类体外声明。   答案：TRUE

题目：19在类中声明常数据成员时，只能通过构造函数成员初始化列表的方式来实现。   答案：FALSE

题目：20类的静态成员函数不可以定义为虚函数。   答案：没有做该题

题目：21虚函数是用virtual 关键字说明的成员函数。   答案：没有做该题

题目：22如果派生类的成员函数的原型与基类中被定义为虚函数的成员函数原型相同，那么，这个函数自动继承基类中虚函数的特性。   答案：没有做该题

题目：23派生类中的虚函数，不仅可以覆盖基类的虚函数，还会隐藏基类中同名函数的所有其它重载形式。  答案：没有做该题

题目：24在构造函数和析构函数中调用虚函数，不是多态。编译时即可确定，调用的函数是自己的类或基类中定义的函数 ，不会等到运行时才决定调用自己的还是派生类的函数。   答案：没有做该题

题目：25可以通过下标随机访问向量vector中的元素。   答案：没有做该题

题目：26当向量对象的内存用完之后，就会产生越界错误。   答案：没有做该题

题目：27set/multiset的区别是set用来存储一组无重复的元素，而multiset允许存储有重复的元素。   答案：没有做该题

题目：28STL中关联型容器都是有序的。   答案：没有做该题

题目：29映射容器里存储的元素都是成对存在的。   答案：没有做该题

题目：30迭代器是对象，它的作用类似于指向元素的指针。   答案：没有做该题

题目：31设置和清除格式标志字的成员函数需要通过对象来引用它们，输出显示格式的对象通常是cout。   答案：没有做该题

题目：32使用打开文件函数open()之前，需要定义一个流类对象，使用open()函数来操作该对象。（。   答案：没有做该题

题目：33使用关闭文件函数close()关闭一个文件时，流对象仍存在。   答案：没有做该题

题目：34打开ASCⅡ码流文件和二进制流文件时，打开方式是相同的。   答案：没有做该题

题目：35seekg()函数和seekp()函数分别用来定位读指针和写指针的。如果使用seek()函数可以同时定义读写指针。   答案：没有做该题


------------------------------------------


题目1:（ ）不是面向对象程序设计的主要特征。  choices=["封装"  "继承"  "多态"  "结构"]   答案：D

题目2:按照标识符的要求，（ ）不能组成标识符。  choices=["连接符"  "下划线"  "大小写字母"  "数字字符"]   答案：A

题目3:cout 是由I/O 流库预定义的（ ）。  choices=["类"  "对象"  "包含文件"  "常量"]   答案：B

题目4:下列表达错误的是（ ）。  choices=["cout<<setw(5)"  "cout<<fill('#')"  "cout.setf(ios::uppercase)"  "cin.fill('#')"]   答案：B

题目5:关于C和C++的描述中，正确的是（ ）  choices=["C是面向过程，C++是纯面向对象"  "C++是C的超集"  "C++是对C的错误的修改"  "C++和C没有关系"]   答案：B

题目6:C++语言支持过程程序设计方法和（ ）设计方法。  choices=["面向对象"  "面向函数"  "面向用户"  "面向问题"]   答案：A

题目7:使用操作符setw对数据进行格式输出时，需要包含（）文件。  choices=["iostream.h"  "fstream.h"  "iomanip.h"  "stdlib.h"]   答案：C

题目8:下列语句中，不能连续输出3个值的是。  choices=["cout<<x<<y<<z;"  "cout<<x  y  z;"  "cout<<x; cout<<y; cout<<z;"  "cout<<(x  y  z)<<(x  y  z)<<(x  y  z);"]   答案：B

题目9:如果默认参数的函数声明为“ void fun(int a,int b=1,char c='a',float d=3.2);”，
则下面调用写法正确的是（ ）。  choices=["fun();"  "fun(2  3);"  "fun(2     'c'  3.14)"  "fun(int a=1);"]   答案：A

题目10:在C++中，关于下列设置缺省参数值的描述中，（）是正确的。  choices=["不允许设置缺省参数值；"  "在指定了缺省值的参数右边，不能出现没有指定缺省值的参数；"  "只能在函数的定义性声明中指定参数的缺省值；"  "设置缺省参数值时，必须全部都设置；"]   答案：B

题目11:对定义重载函数的下列要求中，（ ）是错误的。  choices=["要求参数的个数不同"  "要求参数中至少有一个类型不同"  "要求函数的返回值不同"  "要求参数个数相同时，参数类型不同"]   答案：C

题目12:一个函数为void f(int x, char y = ‘a’)，另一个函数为void f(int)，则它们\_\_\_\_。  choices=["不能在同一程序块中定义"  "可以在同一个程序块中定义并可重载"  "可以在同一个程序块中定义，但不可以重载"  "以上说法均不正确"]   答案：A

题目13:以下有关函数的叙述中正确的是（ ）。  choices=["函数必须返回一个值"  "函数体中必须有return语句"  "两个同名函数，参数表相同而返回值不同不算重载"  "函数执行中形参的改变会改变实参"]   答案：C

题目14:重载函数在调用时选择的依据中，错误的是(??)  choices=["函数的参数"  "参数的类型"  "函数的名字"  "函数的类型"]   答案：C

题目15:以下选项中，是正确的函数默认形参设置的是。  choices=["int fun(int a  int b  int c);"  "int fun(int a  int b  int c=1);"  "int fun(int a  int b=1  int c);"  "int fun(int a=1  int b  int c);"]   答案：B

题目16:设void f1(int * m，long & n)；int a；long b；则以下调用合法的是（）。  choices=["f1(a，b)；"  "f1(&a，b)；"  "f1(a，&b)；"  "f1(&a，&b)；"]   答案：B

题目17:下列对变量的引用中错误的是\_\_\_\_。  choices=["int a; int &p = a;"  "char a; char &p = a;"  "int a; int &p; p=a;"  "loat a; float &p = a;"]   答案：C

题目18:下列关于引用的说法，错误的是\_\_\_\_。  choices=["引用在定义时必须初始化"  "引用在初始化时不能绑定常量值"  "引用初始化后，可以通过更变来引用其他变量"  "数组不能定义引用"]   答案：D

题目19:下列哪一个说法是不正确的?  choices=["某个变量的引用等价于这个变量  相当于该变量的一个别名"  "定义引用时一定要将其初始化成引用某个变量"  "初始化后  它就一直引用该变量不会再别引用别的变量了"  "引用可以引用变量  也可以引用常量和表达式"]   答案：C

题目20:下面程序片段,哪一个是正确的?  choices=["int n=4; int &r=n*3;"  "int m=5; const int &r=m; r=6;"  "int n=8; const int &p=n; int &q=p ;"  "int n=8; int &p=n; const int q=p ;"]   答案：C

题目21:下面程序段 int a=1,b=2; int &r=a; r=b; r=7; cout<<a<<endl; 的输出结果是?  choices=["1"  "2"  "7"  "无法确定"]   答案：C

题目22:如有函数定义：void func(int x = 0, int y = 0){ …. }，则下列函数调用中会出现问题的是\_\_\_\_。  choices=["func(1  2   3);"  "func(1  2);"  "func(1);"  "func();"]   答案：A

题目23:以下正确的函数声明形式是（         ）。  choices=["int func(int x    int y)"  "int func(int    int);"  "int func(int x ; int y);"  "int func(int x    y);"]   答案：D

题目24:顺序执行以下语句后，
int  x=0;
int  &y = x;
x++;
变量y 的值是（      ）。  choices=["0"  "1"  "2"  "不确定"]   答案：B

题目25:分析以下程序：程序的输出结果是
```c++
#include <iostream>
using namespace std;
void fun(int num)
{
    cout << num << endl;
}
void fun(char ch)
{
    cout << (ch + 1) << endl;
}
int main()
{
    fun('A');
    return 0;
}
```  choices=["65"  "66"  "A"  "B"]   答案：D

题目26:以下程序中，new语句干了什么。

int** num;

num = new int* [20];  choices=["分配了长度为20的整数数组空间，并将首元素的指针返回。"  "分配了一个整数变量的空间，并将其初始化为20。"  "分配了长度为20的整数指针数组空间，并将num[0]的指针返回。"  "存在错误，编译不能通过。"]   答案：C

题目27:以下程序存在的问题是：

```
void fun()
{
 int *num1, *num2;
 num1 = new int[10];
 num2 = new int[20];
 num1[0] = 100;
 num2[0] = 300;
 num1 = num2;
 delete [] num1;
}
```  choices=["num2不能给num1赋值"  "num2最初指向的空间没有释放"  "num1最初指向的空间没有释放"  "程序没有问题"]   答案：A

题目28:下列哪一个说法是不正确的?  choices=["T是任意类型名，P是类型为` T * `的指针。`P = new T;` 的含义是:动态分配出一片大小为`sizeof(T)`字节的内存空间，并且将该字节的内存空间起始地址赋值给 P"  "T是任意类型名，P是类型为 `T *` 的指针。N是要分配的数组元素个数，可以是整型表达式。`P = new T[N];` 的含义是:动态分配出一片大小为`sizeof(T) *N`字节的内存空间，并且将该内存空间的起始地址赋值给P"  "用\"`new`\"动态分配的内存空间，不一定要用\"`delete`\"运算符进行释放"  "用\"`new`\"动态分配的数组内存空间，一定要用\"`delete [ ]`\"运算符进行释放"]   答案：C

题目29:下列选项哪一个是正确的?  choices=["char *p=new int; p='a'; delete p;"  "int *p=new int[25]; p[10]=100; delete p;"  "char *p=new char[10]; p[0]='k'; delete [ ] p;"  "char *p=new char; p[0]='k'; delete p;"]   答案：C

题目30:下面定义结构变量的语句中错误的是（）。  choices=["struct student{ int num; char name[20]; } s;"  "struct { int num; char name[20]; } s;"  "struct student{ int num; char name[20]; }; struct student s;"  "struct student{ int num; char name[20]; }; student s;"]   答案：B

题目31:如果有以下定义语句，则输出结果为（）。
```
struct {
      int x, y;
} s[2] = { { 1, 3 }, { 2, 7 } };
printf(“%d\n”, s[0].y/s[1].x );
```  choices=["0"  "1"  "2"  "3"]   答案：B

题目32:根据下面的定义，能打印出字母M的语句是（）。
```
struct person{
      char name[10];
      int age;
} c[10] = { “John”, 17, “Paul”, 19, “Mary”, 18, “Adam”, 16 };
```  choices=["printf(“%c”   c[3].name);"  "printf(“%c”   c[3].name[1]);"  "printf(“%c”   c[2].name[0]);"  "printf(“%c”   c[2].name[1]);"]   答案：C

题目33:设有以下说明语句：
<pre>
struct stu
{
  int a;
  float b;
}stutype;
</pre>  则下面的叙述不正确的是：  choices=["struct是结构体类型的关键字"  "struct stu是用户定义的结构体类型"  "stutype是用户定义的结构体类型名"  "a和b都是结构体成员名"]   答案：C

题目34:设有如下定义，则错误的输入语句是（   ）。
```
struct  ss{ 
  char  name[10];
  int age;  
  char sex;
} std[3], *p = std;
```  choices=["scanf(\"%d\"   &(*p).age);"  "scanf(\"%d\"   p->&age);"  "scanf(\"%c\"   &std[0].sex);"  "scanf(\"%c\"   &(p->sex));"]   答案：B

题目35:有关类和对象的说法下列不正确的有（ ）。  choices=["对象是类的一个实例"  "任何一个对象只能属于一个具体的类"  "一个类只能有一个对象"  "类与对象和关系与数据类型和变量的关系相似"]   答案：C

题目36:在面向对象系统中，对象是基本的运行时实体，它 _____  。  choices=["只能包括数据(属性)"  "只能包括操作(行为)"  "把属性和行为封装为一个整体"  "必须具有显式定义的对象名"]   答案：C

题目37:类的实例化是指（   ）。  choices=["定义类"  "定义对象"  "调用类的成员函数"  "访问对象的数据成员"]   答案：B

题目38:已知类A中的一个成员函数说明为void fun(A &a);，则A &a的含义是（ ）  choices=["将a的地址值赋给变量fun"  "指向类A的指针为a"  "a是类A的对象引用，用来做函数fun()的形参"  "变量A与a按位相与运算后作为函数fun()的参数"]   答案：C

题目39:以下对类A的定义,哪个是正确的?  choices=["`class A{\n\tprivate:int v;\n\tpublic:void fun(){}\n}`"  "`class A{\n\tint v;\n\tA * next;\n\tvoid fun(){}\n};`"  "`class A{\n\tint v;\npublic:\n\tvoid fun();\n};\nA::void fun(){}`"  "`class A{\n\tint v;\npublic:\n\tA next;\n\tvoid fun(){}\n};`"]   答案：C

题目40:下列对重载函数的描述中，（ ）是错误的。  choices=["重载函数中不允许使用默认参数"  "重载函数中编译根据参数表进行选择"  "不要使用重载函数来描述毫无相干的函数"  "构造函数重载将会给初始化带来多种方式"]   答案：A

题目41:在下列关键字中,用以说明类中公有成员的是（ ）。  choices=["public"  "private"  "protected"  "friend"]   答案：A

题目42:在下面类声明中，关于生成对象不正确的是（ ）。
class point
{ public:
         int x;
         int y;
         point(int a,int b)   {x=a;y=b;}
};  choices=["point p(10  2);"  "point *p=new    point(1  2);"  "point *p=new point[2];"  "point *p[2]={new point(1  2)   new  point(3  4)};"]   答案：C

题目43: 如果类定义中没有使用 private、protected、或public 关键字，则所有成员（ ）  choices=["都是 public 成员"  "都是 proctected 成员"  "都是 private 成员"  "不一定"]   答案：A

题目44:设类AA已定义，假设以下语句全部合法，哪些语句会触发调用构造函数（  ）。

```
AA a; //1
AA b(12, 10); //2
AA c(b); //3
a.SetX(32); //4
```  choices=["1 和 2"  "1、2 和 3"  "全班"  "1"]   答案：B

题目45:下面程序的运行结果为
```
#include<iostream.h>
class A
{
public:
   A（）{cout<<"1";}
   ~A（）{cout<<"2";}
};
class B:public A
{
public:
     B（）{cout<<"3";}
     ~B（）{cout<<"4";}
};
void main（）
{  B b; }
```  choices=["1234"  "1324"  "1342"  "3142"]   答案：C

题目46:下面程序的运行结果为
```
#include<iostream.h>
class A
{
  int num;
public:
  A（int i）{num=i;}
  A（A &a）{num=a.num++;}
  void print（）{cout<<num;}
};
void main（）
{
  A a （1）,b（a）;
  a.print（）;
  b.print（）;
}
```  choices=["11"  "12"  "21"  "22"]   答案：B

题目47:类的析构函数是在什么时候调用的？  choices=["类创建时"  "创建对象时"  "删除对象时"  "不自动调用"]   答案：C

题目48:下面对于析构函数的描述中，正确的是（      ）  choices=["析构函数是系统的内置函。"  "析构函数名称为在类名或者构造函数名之前加一个“~”"  "析构函数，既然是函数，同样可以带有参数"  "只有用delete关键字删除对象时，系统才会自动调用析构函数。"]   答案：B

题目49:假设A是一个类的名字，下面程序片段，类A会调用析构函数几次？
int main(){
A `* p = new A[2];`
A `* p2 = new A;`
A a;
delete [] p;
}  choices=["1"  "2"  "3"  "4"]   答案：B

题目50:下列关于对象数组的描述中，错误的是（）  choices=["对象数组的下标是从零开始的"  "对象数组的数组名是一个常量指针"  "对象数组的每个元素是同一个类的对象"  "对象数组只能赋初值，而不能被赋值"]   答案：D

题目51:以下程序段,哪个是不正确的?  choices=["`int main()\n{\n\tclass A { int v; };\n\tA a; a.v = 3; return 0;\n}`"  "`int main()\n{\n\tclass A { public:int v;A *p; };\n\tA a; a.p=&a; return 0;\n}`"  "`int main()\n{\n\tclass A { public:int v; };\n\tA *p=new A;\n\tp->v=4; delete p;\n\treturn 0;\n}`"  "`int main()\n{\n\tclass A { public:int v; A *p; };\n\tA a;\n\ta.p=new A;\n\tdelete a.p;\n\treturn 0;\n}`"]   答案：B

题目52:一个类的私有成员  choices=["只能被该类的成员函数访问"  "只能被该类的成员函数和友元函数访问"  "只能被该类的成员函数、友元函数和派生类访问"  "以上答案都不对"]   答案：B

题目53:在公有继承的情况下，在派生类中能够访问的基类成员包括  choices=["公有成员"  "保护成员"  "公有成员、保护成员和私有成员"  "公有成员和保护成员"]   答案：D

题目54:派生类继承基类的方式有  choices=["public"  "private"  "protected"  "以上都对"]   答案：D

题目55:下面关于类的继承与派生的程序，其输出结果是
```C++
#include<iostream>
using namespace std;
class A
{
public:
    A(){cout<<"A";}
};
class B
{
public:
    B(){cout<<"B";}
};
class C:public A
{
    B b;
public:
    C(){cout<<"C";}
};
int main(){
    C obj;
    return 0;
}
```  choices=["CBA"  "BAC"  "ACB"  "ABC"]   答案：D

题目56:若obj是类D的对象，则下列语句中正确的是
```C++
class B{
private: void fun1(){ }
protected: void fun2(){ }
public: void fun3(){ }
};
class D : public B {
protected: void fun4(){ }
};
```  choices=["obj.fun1();"  "obj.fun2();"  "obj.fun4();"  "obj.fun3();"]   答案：D

题目57:下面，有关派生类构造函数的论述，错误的是（    ）  choices=["派生类构造函数，需要为基类构造函数传递参数；"  "派生类构造函数，需要为内嵌子对象的初始化传递参数；"  "派生类构造函数，仅对派生类的新增数据成员初始化传递参数；"  "派生类构造函数，可以采用初始化列表的方式为常成员函数传递初始化参数。"]   答案：C

题目58:创建一个类A；然后通过继承的方式由类A派生出类B，则下列关于派生中构造函数和析构函数的描述中正确的是：  choices=["类B继承了类A的构造函数"  "类B继承了类A的析构函数"  "创建类B的对象时，先执行类A的构造函数，然后执行类B的构造函数"  "撤销类B的对象时，先执行类A的析构函数，然后执行类B的析构函数"]   答案：C

题目59:如果多种事物，有一些共同的特点又各自不同的特点，如何编写类来代表这些事物比较合适？  choices=["为每种事物独立编写一个类，各之间互相无关"  "写一个类代表其中一种事物，代表其他事物的类都从这个类派生出来"  "概括所有事物的共同特点，写一个基类。然后为每种事物写一个类，都从基派生而来"  "一共就写一个类，包含所有事物的所有特点，然后用一个成员变量作为标记，来区分不同种类的事物"]   答案：C

题目60:以下说法正确的是？  choices=["派生类可以和基类有同名成员函数，但是不能有同名成员变量"  "派生类的成员函数中，可以调用基类的同名同参数表的成员函数"  "派生类和基类的同名成员函数必须参数表不同，否则就是重复定义"  "派生类和基类的同名成员变量存放在相同存储空间"]   答案：B

题目61:若派生类的成员函数不能直接访问基类中的某个成员，则该成员一定是基类中的（）。  choices=["私有成员"  "公有成员"  "保护成员"  "私有成员或保护成员"]   答案：A

题目62:在创建派生类对象时，构造函数的执行顺序是(    )。  choices=["对象成员构造函数、基类构造函数、派生类本身的构造函数"  "基类构造函数、对象成员构造函数、派生类本身的构造函数"  "基类构造函数、派生类本身的构造函数、对象成员构造函数"  "派生类本身的构造函数、基类构造函数、对象成员构造函数"]   答案：B

题目63:下面程序的输出结果是
```C++
#include <iostream>
using namespace std;

class MyClass {
public:
    MyClass() {
        ++count;
    }
    ~MyClass() {
        --count;
    }
    static int getCount() {
        return count;
    }
private:
    static int count;
};
int MyClass::count = 0;
int main() {
    MyClass obj;
    cout << obj.getCount();
    MyClass obj2;
    cout << MyClass::getCount();
    cout << obj2.getCount();
    return 0;
}
```  choices=["121"  "232"  "221"  "122"]   答案：没有做该题

题目64:对类的数据成员或内嵌对象进行初始化时，不属于必须采用构造函数的初始化列表方式进行初始化的是（      ）  choices=["内嵌对象"  "常数据成员"  "静态数据成员"  "对虚基类的初始化"]   答案：没有做该题

题目65:关于静态数据成员描述正确的是( ).  choices=["静态成员的初始化是在构造函数中完成的"  "静态成员被所有本类对象所共享"  "静态成员必须通过类名调用"  "静态成员必须通过对象名调用"]   答案：没有做该题

题目66:子对象的初始化是通过( )来实现的.  choices=["构造函数"  "成员函数"  "构造函数的成员初始化列表"  "友元函数"]   答案：没有做该题

题目67:以下说法正确的是？  choices=["在静态成员函数中可以调用同类的其他任何成员函数"  "const成员函数不能作用于非 const 对象"  "在静态成员函数中不能使用 this 指针"  "静态成员变量每个对象有各自的一份"]   答案：没有做该题

题目68:关于this指针的描述中，错误的是（）。  choices=["this指针是指向对象的指针"  "this指针是在使用对象引用成员函数时，系统自动生成的"  "this指针可以在程序中显示使用"  "this指针是指向成员函数的指针"]   答案：没有做该题

题目69:在下面有关静态成员函数的描述中，正确的是（）。  choices=["在建立对象前，就可以为静态数据成员赋值"  "静态成员函数在类外定义时要用static前缀"  "静态成员函数只能在类外定义"  "在静态成员函数中可以使用this指针"]   答案：没有做该题

题目70:下列选项中，静态成员函数不能直接访问的是（）。  choices=["静态数据成员"  "静态成员函数"  "类以外的函数和数据"  "非静态数据成员"]   答案：没有做该题

题目71:下列描述中，（ ）是抽象类的特性。  choices=["可以说明虚函数"  "可以进行构造函数重载"  "可以定义友元函数"  "不能定义该类对象"]   答案：没有做该题

题目72:如果在基类中将show声明为不带返回值的纯虚函数，正确的写法是（）。  choices=["virtual show()=0;"  "virtual void show();"  "virtual void show()=0;"  "void show()=0 virtual;"]   答案：没有做该题

题目73:若一个类中含有纯虚函数，则该类称为。  choices=["基类"  "纯基类"  "抽象类"  "派生类"]   答案：没有做该题

题目74:假设 Aclass为抽象类，下列正确的说明语句是。  choices=["Aclass fun( int ) ;"  "Aclass * p ;"  "int fun( Aclass ) ;"  "Aclass Obj ;"]   答案：没有做该题

题目75:可以用p.a的形式访问派生类对象p的基类成员a, 其中a是  choices=["私有继承的公有成员"  "公有继承的私有成员"  "公有继承的保护成员"  "公有继承的公有成员"]   答案：没有做该题

题目76:关于虚函数的描述中，（ ）是正确的。  choices=["虚函数是一个static 类型的成员函数"  "虚函数是一个非成员函数"  "基类中说明了虚函数后，派生类中与其对应的函数可不必说明为虚函数"  "派生类的虚函数与基类的虚函数具有不同的参数个数和类型"]   答案：没有做该题

题目77:设有如下代码段:

```
class A {
public:
    void func1() {
        cout << "A1" << endl;
    }
    virtual void func2() {
        cout << "A2" << endl;
    }
};
class B : public A {
public:
    void func1() {
        cout << "B1" << endl;
    }
    void func2() {
        cout << "B2" << endl;
    }
};

int main() {
    A *a = new B;
    a->func1();
    a->func2();
}
```
则输出结果为:  choices=["A1 A2"  "A1 B2"  "B1 A2"  "B1 B2"]   答案：没有做该题

题目78:关于函数模板，描述错误的是。  choices=["函数模板必须由程序员实例化为可执行的函数模板"  "函数模板的实例化由编译器实现"  "一个类定义中，只要有一个函数模板，则这个类是类模板"  "类模板的成员函数都是函数模板，类模板实例化后，成员函数也随之实例化"]   答案：没有做该题

题目79:下列的模板说明中，正确的是。  choices=["template < typename T1   T2 >"  "template < class T1   T2 >"  "template < typename T1   typename T2 >"  "template ( typedef T1   typedef T2 )"]   答案：没有做该题

题目80:有函数模板定义如下：
```c++
template<typename T>
Max(T a, T b, T& c){c = a + b ;}
```
则下列调用中正确的是\_\_\_\_。  choices=["int x   y; char z; Max(x   y   z);"  "double x   y  z; Max(x   y   z);"  "int x   y; float z; Max(x   y   z);"  "float x   double y   z; Max(x   y   z);"]   答案：没有做该题

题目81:类模板的模板参数\_\_\_\_。  choices=["只可作为数据成员的类型"  "可作为成员函数的返回类型"  "可作为成员函数的参数类型"  "以上三者皆可"]   答案：没有做该题

题目82:类模板的使用实际上是将类模板实例化成一个\_\_\_\_。  choices=["函数"  "对象"  "类"  "抽象类"]   答案：没有做该题

题目83:下列关于模板的说法中，错误的是\_\_\_\_。  choices=["用模板定义一个对象时，不能省略参数"  "类模板只能有虚拟参数类型"  "类模板的成员函数都是模板函数"  "类模板在编绎中不会生成任何代码"]   答案：没有做该题

题目84:一个\_\_\_\_允许用户为类定义一种模式，使得类中的某些数据成员及某些成员函数的返回值能取任意类型。  choices=["函数模板"  "模板函数"  "类模板"  "模板类"]   答案：没有做该题

题目85:若有下面的语句：
```C++
vector<int> v;
for (int i = 0; i < 4; i++)
    v.push_back(i + 1);
cout << v.size() << endl;
```
则执行后程序的输出结果是  choices=["1"  "2"  "3"  "4"]   答案：没有做该题

题目86:设有定义 `vector<string> v(10); `
执行下列哪条语句时会调用构造函数?  choices=["`v[0] += \"abc\"; `"  "`v[0] = \"2018\";`"  "`v.push_back(\"ZUCC\");`"  "`cout << (v[1] == \"def\"); `"]   答案：没有做该题

题目87:设有如下代码段:
```
std::map<char *, int> m;
const int MAX_SIZE = 100;
int main() {
    char str[MAX_SIZE];
    for (int i = 0; i < 10; i++) {
        std::cin >> str;
        m[str] = i;
    }
    std::cout << m.size() << std::endl;
}

```
读入10个字符串，则输出的 `m.size()` 为  choices=["0"  "1"  "10"]   答案：没有做该题

题目88:下列关于STL的描述中，错误的是。  choices=["STL的内容从广义上讲分为容器、迭代器、算法三个主要部分"  "STL的一个基本理念就是将数据和操作分离"  "STL中的所有组件都由模板构成，其元素可以是任意类型"  "STL的容器、迭代器、算法是三个完全独立的部分，彼此也无任何联系"]   答案：没有做该题

题目89:下列创建vector容器对象的方法中，错误的是。  choices=["`vector<int> v(10);`"  "`vector<int> v(10   1);`"  "`vector<int> v{10   1};`"  "`vector<int> v = (10   1);`"]   答案：没有做该题

题目90:若有下面的语句：
```C++
string s="Hello";
s.append("123");
cout << s.at(5) << endl;
```
则执行后程序的输出结果是  choices=["o"  "1"  "2"  "3"]   答案：没有做该题

题目91:关于用string定义字符串，下列选项中错误的是\_\_\_\_。  choices=["string s; s = \"hello C++\";"  "string s = \"hello C++\";"  "string s(\"hello C++\");"  "string s[\"hello C++\"];"]   答案：没有做该题

题目92:使用C++标准string类定义一个字符串，需要包含的头文件\_\_\_\_。  choices=["string.h"  "string"  "cstring"  "stdlib.h"]   答案：没有做该题

题目93:以下初始化语句正确的是（      ）。  choices=["string * p=\"this\" ;"  "string  p[ ]=\"that\";"  "string p[ ]={\"What\"  \"this\"};"  "char * p={ \"Please\" } ;"]   答案：没有做该题

题目94:下面是关于ios 类的叙述，正确的是（ ）。  choices=["它是istream 类和ostream 类的虚基类"  "它只是istream 类的虚基类"  "它只是ostream 类的虚基类"  "它是iostrearm 类的虚基类"]   答案：没有做该题

题目95:当使用ifstream 流类定义一个流对象并打开一个磁盘文件时，文件的隐含打开方式为（ ）。  choices=["ios::in"  "ios::out"  "ios::in|ios::out"  "ios::binary"]   答案：没有做该题

题目96:下列函数中，（ ）是对文件进行写操作的。  choices=["get"  "read"  "seekg"  "put"]   答案：没有做该题

题目97:在C++中，打开一个文件，就是将整个文件与一个（ ）建立关联，关闭一个文件，就是取消这种关联。  choices=["类"  "流"  "对象"  "结构"]   答案：没有做该题

题目98:对磁盘文件进行操作时，以\_\_\_\_模式打开的文件，可实现创建一个可以写入的、新的空文件；如果该文件已经存在，则先删除以前的内容，再写入新数据。  choices=["ios::in"  "ios::app"  "ios::out"  "ios::binary"]   答案：没有做该题

题目99:使用“myFile.open("Sales.dat",ios::app);”语句打开文件Sales.date后，则（）。  choices=["该文件只能用于输出"  "该文件只能用于输入"  "该文件既可以用于输出，也可以用于输入"  "若该文件存在，则清除该文件的内容"]   答案：没有做该题


------------------------------------------

题目1:
题目：测试c++ 1 分难度：7-1
正文：
倒序输出从控制台输入的n个整数

### 输入格式:

第一行输入一个数n，代表行数  
依次输入n个整数

### 输出格式:

将n个整数倒序输出

### 输入样例:
```in
3
1 2 3
```

### 输出样例:
```out
321
```

答案：
#include<iostream>
using namespace std;
int main(void){
    int n;
    int i=0;
    cin>>n;
    int c[n];
    while(i<n){

        cin>>c[i];
        i++;
    }
    while((--n)>=0){
        cout<<c[n];
    }
    return 0;
}

------------------------


题目2:
题目：计算三角形面积 10 分难度：7-2
正文：
从键盘输入三个数，用来表示三角形的三条边长。如果能构成三角形就输出三角形的面积，否则就输出No。

### 输入格式:

请在这里写输入三角形的三条边长，例如：
3.1   4.2   5.3
### 输出格式:
请在这里输出三角形的面积，例如：

6.50661
### 输入样例:
```in
3.0 4.0 5.0
```

### 输出样例:
```out
6
```

答案：
#include<iostream>
#include<math.h>
using namespace std;
double max(double a,double b,double c){
	double temp=a>b?a:b;
	double max1=temp>c?temp:c;
	return max1;
}
double min(double a,double b,double c){
	double temp=a<b?a:b;
	double min1=temp<c?temp:c;
	return min1;
}
double findtemp(double *a,double max,double min){
	for(double *i=a;i<a+3;i++){
		if(max!=*i&&min!=*i){
			return *i;
		}
	} 
}
int main(void){
    double a[3];
    for(int i=0;i<3;i++){
    	cin>>a[i];
	}
    double max1=max(a[0],a[1],a[2]);
    double min1=min(a[0],a[1],a[2]);
    double temp=findtemp(a,max1,min1);
    if((min1+temp)>max1&&(max1-temp)<min1){
    	double p=(max1+min1+temp)/2;
    	double s=p*(p-a[0])*(p-a[1])*(p-a[2]);
    	s=sqrt(s);
    	cout<<s;
	}else{
		cout<<"No"; 
	} 
}

------------------------


题目3:
题目：问候 10 分难度：7-3
正文：
输出问候：Hello!What's your name?
从键盘输入名字，然后输出欢迎信息。

### 输入格式:

请在这里写输入姓名。例如：
GaiFuShuai

### 输出格式:

请在这里描述输出，例如：

Hello!What's your name?

GaiFuShuai,Welcome to learn OOP using C++!

### 输入样例:
```in
BaiFuMei
```

### 输出样例:
```out
Hello!What's your name?
BaiFuMei,Welcome to learn OOP using C++!
```

答案：
#include<iostream>
#include<math.h>
using namespace std;
int main(void){
 	cout<<"Hello!What's your name?\n";
 	string name;
 	cin>>name;
 	cout<<name<<",Welcome to learn OOP using C++!";
}

------------------------


题目4:
题目：求交错序列前N项和 15 分难度：7-4
正文：
本题要求编写程序，计算交错序列 1-2/3+3/5-4/7+5/9-6/11+... 的前N项之和。

### 输入格式:

输入在一行中给出一个正整数N。

### 输出格式:

在一行中输出部分和的值，结果保留三位小数。

### 输入样例:
```in
5
```

### 输出样例:
```out
0.917
```

答案：
#include<iostream>
#include<math.h>
#include <iomanip>
using namespace std;
double findres(int n){
	int i=1;
	bool istrue=false;
	double res=1;
	while(i<n){
		i++;
		if(istrue){
			res+=( (double)i / (i+i-1) );
			istrue=false;
		}else{
			res-=( (double)i / (i+i-1) );
			istrue=true;
		}
		
		
	}
	return res;
}
int main(void){
 	int n;
 	cin>>n;
 	double res=findres(n);
 	cout<<setiosflags(ios::fixed)<<setprecision(3);
	 cout<<res;
}

------------------------


题目5:
题目：特殊a串数列求和 20 分难度：7-5
正文：
给定两个均不超过9的正整数$$a$$和$$n$$，要求编写程序求$$a+aa+aaa++\cdots +aa\cdots a$$（$$n$$个$$a$$）之和。

### 输入格式：

输入在一行中给出不超过9的正整数$$a$$和$$n$$。

### 输出格式：

在一行中按照“s = 对应的和”的格式输出。

### 输入样例：
```in
2 3
```

### 输出样例：
```out
s = 246
```

答案：
#include<iostream>
#include<math.h>
using namespace std;
int main(void){
	unsigned a,n;
	cin>>a>>n;
	if(a>9||n>9){
		return 0;
	}
	int i=0;
	int res=0;
    int temp=0;
	while(i<n){
        i++;
        temp=temp*10+a;
        res+=temp;
	}
	cout<<"s = "<<res;
}

------------------------


题目6:
题目：统计一行文本的单词个数 15 分难度：7-6
正文：
本题目要求编写程序统计一行字符中单词的个数。所谓“单词”是指连续不含空格的字符串，各单词之间用空格分隔，空格数可以是多个。

### 输入格式:

输入给出一行字符。 

### 输出格式:

在一行中输出单词个数。 

### 输入样例:
```in
Let's go to room 209.
```

### 输出样例:
```out
5
```

答案：
#include<iostream>
using namespace std;
int main(void){
	char ch;
	int num=0;
	int size=0;
	bool is=true;
	while(1){
		scanf("%c",&ch);
		if(ch=='\n'){
			break;
		}else if(ch!=' '){
			size++;
			is=true;
			
		}else if(ch==' '){
			if(size>0){
				num++;
			is=false;
			size=0;	
			}
		
		}
		
	}
	if(size>0){
			num++;
		}
	//cout<<num;
	printf("%d",num);
}

------------------------


题目7:
题目：鸿鸿哥分钱 15 分难度：7-7
正文：
鸿鸿哥最近和一个小伙伴做了个小项目，赚了一个亿，两人一起高高兴兴开了庆功宴之后，鸿鸿哥就准备分一下钱了。鸿鸿哥想了想，生意不是做一天的，所以一个亿之中的大部分资金还是要继续投资，不能只是做一发就走，这个想法也得到了小伙伴的认可。而余下来的钱不知道具体数值，只知道是x万~y万之间（因为某种神秘力量余下的钱一定是偶数万）。而鸿鸿哥原本也是土豪，这点小钱也看不上眼，于是他想分多一点给小伙伴，他决定把钱分成两个素数（程序员喜欢各种特别的数字），自己拿小的那份。那么问题来了，鸿鸿哥和小伙伴个各拿多少万呢？鸿鸿哥想知道所有可能的分法。

### 输入格式:

输入两个整数x，y（6<=x，x<=y，n<=100），一组输入。

### 输出格式:

输出x和y之间所有偶数表示成的两个素数之和。

### 输入样例:

在这里给出一组输入。例如：

```in
8 10
```

### 输出样例:

在这里给出相应的输出。例如：

```out
8=3+5 
10=3+7
```


答案：
#include<iostream>
#include<cmath>
using namespace std;
inline bool isnum(int num){
	if(num<2){
		return false;
	}
	for(int i=2;i<num;i++){
		if(num%i==0){
		
			return false;
			
		}
	}
	return true;
}
int main(void){
	int x,y;
	cin>>x>>y;
	for(int i=x;i<=y;i++){
		if(i%2==0){
			for(int k=2;k<i;k++){
				if(isnum(k)&&isnum(i-k)){
					cout<<i<<"="<<k<<"+"<<i-k<<endl;
					break;
				}
			}
		}
	}
	return 0;
}

------------------------


题目8:
题目：估值一亿的AI核心代码 20 分难度：7-8
正文：

![AI.jpg](~/3e7829fa-ed75-4890-acca-54a00fbac9d3.jpg)


以上图片来自新浪微博。

本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是：

- 无论用户说什么，首先把对方说的话在一行中原样打印出来；
- 消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉；
- 把原文中所有大写英文字母变成小写，除了 `I`；
- 把原文中所有独立的 `can you`、`could you` 对应地换成 `I can`、`I could`―― 这里“独立”是指被空格或标点符号分隔开的单词；
- 把原文中所有独立的 `I` 和 `me` 换成 `you`；
- 把原文中所有的问号 `?` 换成惊叹号 `!`；
- 在一行中输出替换后的句子作为 AI 的回答。

### 输入格式：

输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。

### 输出格式：

按题面要求输出，每个 AI 的回答前要加上 `AI:` 和一个空格。

### 输入样例：
```in
6
Hello ?
 Good to chat   with you
can   you speak Chinese?
Really?
Could you show me 5
What Is this prime? I,don 't know
```

### 输出样例：
```out
Hello ?
AI: hello!
 Good to chat   with you
AI: good to chat with you
can   you speak Chinese?
AI: I can speak chinese!
Really?
AI: really!
Could you show me 5
AI: I could show you 5
What Is this prime? I,don 't know
AI: what Is this prime! you,don't know
```


答案：
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin >> n;
	getchar();  // 吸收换行 
	string s;
	while(n--){
		string str[1005];
		int cnt=0;
		getline(cin,s);
		cout << s << endl << "AI:";
		for(int i=0;i<s.size();++i){
			if(isalnum(s[i])){
				if(s[i]!='I')
					s[i]=tolower(s[i]);
			}
			else{
				s.insert(i," ");    //对每个非字母和数字之前加空格
				i++;
			}
			if(s[i]=='?')
				s[i]='!';
		}
		stringstream ss(s);        //主要依靠这个函数来取消单词之前的空格
		while(ss >> s){
			str[cnt++]=s;
		}
		if(!isalnum(str[0][0]))     		// 如果 第一个单词的第一个位置就是标点  那么要输出一个空格，题中要求 每个 AI 的回答前要加上 AI: 和一个空格。
			cout << " ";
		for(int i=0;i<cnt;++i){
			if(!isalnum(str[i][0])){         // 判断第一个字符是否是 标点，标点前面不要输出空格
				cout << str[i];
			}
			else if((str[i]=="can" || str[i]=="could") && str[i+1]=="you"){ // &&优先级大于|| ,所以要加括号 
				cout << " I " << str[i];
				i++;
			}
			else if(str[i]=="I" || str[i]=="me"){
				cout << " you";
			}
			else
				cout << " " << str[i];
		}
		cout << endl;
	}
} 


------------------------


题目9:
题目：实数排序 20 分难度：7-9
正文：
本题要求编写程序，输入n个实数，使用指针引用的方式将它们按从大到小的顺序排列。

### 输入格式:

输入第一行给出一个正整数n（2≤n≤10）,输入第二行给出n个实数，其间以空格分隔。

### 输出格式:

输出从大到小排好序的n个数（保留2位小数），每个数之间空一格，行末没有空格。

### 输入样例:

在这里给出一组输入。例如：

```in
5
3.2 5.4 6.12 2.51 4.23
```

### 输出样例:

在这里给出相应的输出。例如：

```out
6.12 5.40 4.23 3.20 2.51
```


答案：
#include<iostream>
#include<iomanip>
using namespace std;
void sort(double *p,int num){//降序排序 
	//int num=sizeof(p)/sizeof(int);
	//cout<<num<<endl;
	for(double *i=p;i<p+(num-1);i++){
		for(double *j=i;j<p+num;j++){
			if(*j>*i){
				
			double t=*i;
			*i=*j;
			*j=t;
				
			}
		}
	}
}
int main(void){
    int n;
    cin>>n;
    double num[n];
    for(int i=0;i<n;i++){
        cin>>num[i];
    }
    sort(num,n);
    for(int i=0;i<n-1;i++){
        cout<<fixed<<setprecision(2)<<num[i]<<" ";
    }
    cout<<num[n-1];


    return 0;
}

------------------------


题目10:
题目：字符串的连接 15 分难度：7-10
正文：
本题要求编写程序，使用指针方式实现两个字符串的连接(不能使用strcat函数），并将连接后的字符串输出。

### 输入格式:

输入一行以回车结束的非空字符串（不超过40个字符），再输入一行以回车结束的非空字符串（不超过40个字符）。

### 输出格式:

一行输出俩字符串连接后新的字符串。

### 输入样例:



```in
Beijing_
China
```

### 输出样例:

```out
Beijing_China
```


答案：
#include<iostream>
#include<string>
using namespace std;
int main(void){
   string a,b;
   getline(cin,a);
   getline(cin,b);
   char c[100];
   int i=0,j=0;
   while(a[i]!='\0'){
       c[i]=a[i];
       i++;
   }
    while(b[j]!='\0'){
        c[i+j]=b[j];
        j++;
    }
    //最后需要加上  \0
    c[i+j]='\0';
    puts(c);
    return 0;
}

------------------------


题目11:
题目：使用函数删除字符串中的字符 10 分难度：7-11
正文：
输入一个正整数 repeat (0<repeat<10)，做 repeat 次下列运算：

输入一个字符串 str，再输入一个字符 c，将字符串 str 中出现的所有字符 c 删除。

要求定义并调用函数delchar(str,c), 它的功能是将字符串 str 中出现的所有 c 字符删除，函数形参str的类型是字符指针，形参c的类型是char，函数类型是void。

输入输出示例：括号内为说明，无需输入输出

### 输入样例:
```in
3               (repeat=3）
happy new year  (字符串"happy new year")
a               (待删除的字符'a')
bee             (字符串"bee")
e               (待删除的字符'e')
111211          (字符串"111211")
1               (待删除的字符'1')
```

### 输出样例:
```out
result: hppy new yer    (字符串"happy new year"中的字符'a'都被删除)
result: b               (字符串"bee"中的字符'e'都被删除)
result: 2               (字符串"111211"中的字符'1'都被删除)
```

答案：
#include<iostream>
#include<string.h>
using namespace std;
void delchar(char* str,char ch){
//	int len=sizeof(str)/sizeof(char);
	int len=strlen(str);
	//cout<<"len="<<len; 
	int t=0;
	for(int i=0;i<len;i++){
		if(str[i]==ch){
			//如果这个字符不是最后一个则这个字符被后面的字符覆盖，并且后面字符全部向前面移动一位
			 t=i;
			 	while(str[t+1]!='\0'){
			 		str[t]=str[t+1];
			 		t++;
				 }
			 	str[t]='\0';
			 //	len--;
			 	i--;
		}
	}
	cout<<"result: "<<str;
}
int main(void){
	int n;
	cin>>n;
	char str[100];
   // string str;
	char ch;
	getchar();
	for(int i=0;i<n;i++){
		fgets(str,100,stdin);
        //getline(cin,str);
		cin>>ch;
		getchar();
		delchar(str,ch);
	}
	return 0;
}
             


------------------------


题目12:
题目：学生的平均成绩 10 分难度：7-59
正文：
有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），其中学号和姓名都是以字符串方式存储，计算出每名学生的平均成绩，

### 输入格式:

分别在5行中输入5名学生的信息。按照学号、姓名、3门课的成绩顺序输入，学号和姓名是均不超过4个字符的字符串，字符串中不包含空格、换行符和制表符，一名学生的各个数据之间用一个空格间隔。

### 输出格式:

分别在5行中输出5名学生的信息。按照学号、姓名、3门课的平均成绩顺序输出，其中学号和姓名输出占5列列宽，平均成绩保留1位小数，输出占5列列宽。

### 输入样例:
```in
1 aa 78 45 12
2 bb 95 85 95
3 cc 75 45 65
4 dd 74 84 95
5 ee 48 49 56
```

### 输出样例:
```out
    1   aa 45.0
    2   bb 91.7
    3   cc 61.7
    4   dd 84.3
    5   ee 51.0
```

答案：
#include<iostream>
#include<iomanip>
using namespace std;
int main(void){
    int n=5;
    double a,b,c;
    double res;
    string name;
    int class_stu;
    for(int i=0;i<n;i++){
    	cin>>class_stu;
    	cin>>name;
        cin>>a>>b>>c;
        res=(a+b+c)/3;
        cout<<setw(5)<<class_stu<<setw(5)<<name<<" ";
        cout<<fixed<<setprecision(1)<<res<<endl;
    }

    return 0;
}

------------------------


题目13:
题目：找出总分最高的学生 10 分难度：7-60
正文：
给定N个学生的基本信息，包括学号（由5个数字组成的字符串）、姓名（长度小于10的不包含空白字符的非空字符串）和3门课程的成绩（[0,100]区间内的整数），要求输出总分最高学生的姓名、学号和总分。

### 输入格式：

输入在一行中给出正整数N（$$\le$$10）。随后N行，每行给出一位学生的信息，格式为“学号 姓名 成绩1 成绩2 成绩3”，中间以空格分隔。

### 输出格式：

在一行中输出总分最高学生的姓名、学号和总分，间隔一个空格。题目保证这样的学生是唯一的。

### 输入样例：
```in
5
00001 huanglan 78 83 75
00002 wanghai 76 80 77
00003 shenqiang 87 83 76
10001 zhangfeng 92 88 78
21987 zhangmeng 80 82 75
```

### 输出样例：
```out
zhangfeng 10001 258
```

答案：
#include<iostream>
using namespace std;
int main(void){
    int n;
    cin>>n;
    string class_stru;
   string res_sut;//学号要字符串,前面的0
    string name;
    string res_name;
    int a,b,c,res;
    res=0;
    cin>>class_stru>>name>>a>>b>>c;
    res=(a+b+c);
    res_sut=class_stru;
    res_name=name;
    for(int i=0;i<n-1;i++){
        cin>>class_stru>>name>>a>>b>>c;
        if((a+b+c)>res){
            res=(a+b+c);
            res_name=name;
            res_sut=class_stru;
        }
    }
    cout<<res_name<<" "<<res_sut<<" "<<res;
    return 0;
}

------------------------


题目14:
题目：一帮一 10 分难度：7-61
正文：
“一帮一学习小组”是中小学中常见的学习组织方式，老师把学习成绩靠前的学生跟学习成绩靠后的学生排在一组。本题就请你编写程序帮助老师自动完成这个分配工作，即在得到全班学生的排名后，在当前尚未分组的学生中，将名次最靠前的学生与名次最靠后的**异性**学生分为一组。

### 输入格式：

输入第一行给出正偶数`N`（$$\le$$50），即全班学生的人数。此后`N`行，按照名次从高到低的顺序给出每个学生的性别（0代表女生，1代表男生）和姓名（不超过8个英文字母的非空字符串），其间以1个空格分隔。这里保证本班男女比例是1:1，并且没有并列名次。

### 输出格式：

每行输出一组两个学生的姓名，其间以1个空格分隔。名次高的学生在前，名次低的学生在后。小组的输出顺序按照前面学生的名次从高到低排列。

### 输入样例：
```in
8
0 Amy
1 Tom
1 Bill
0 Cindy
0 Maya
1 John
1 Jack
0 Linda
```

### 输出样例：
```out
Amy Jack
Tom Linda
Bill Maya
Cindy John
```

答案：
#include <stdio.h>
int main()
{
int N,a[50],i;
char b[50][100];
int j;
scanf("%d",&N);
for(i=0; i<N; i++)
{
scanf("%d",&a[i]);
scanf("%s",&b[i]);
}
for(i=0; i<N; i++)
{
for(j=N-1; j>=0; j--)
{
if(a[i]!=a[j]&&a[i]<=1&&a[j]<=1)
{
a[i]=2;///等于2是因为男生是1，女生是0.等于2再搭配上面的条件就可以把已经比较了的排除
a[j]=2;
printf("%s %s\n",b[i],b[j]);
break;
}
}
}
return 0;
}

------------------------


题目15:
题目：领装备 15 分难度：7-62
正文：
鸿鸿哥最近在一个游戏公司做兼职，负责后台的数据管理。该公司的游戏最近正值2周年活动，为了感谢玩家们长久以来的支持，公司总裁决定给予玩家们感恩大回馈――活动期间只要登录游戏，就能获得稀有装备（稀有装备也分星级，星级越高越好）。其具体实施方法如下：每个玩家凭借自己的玩家号领取一个号码牌，然后用号码牌进行兑换稀有装备。注意：总裁的恶趣味来了，领取的号码牌并非越大越好，号码大并非就代表装备的星级高，星级是随机生成的。而鸿鸿哥任务是根据生成的数据来发放装备给玩家。你能编程帮助鸿鸿哥解决这个问题吗？

### 输入格式:
输入第一行给出一个正整数?N（≤1000），代表参与游戏的玩家个数。
随后?N?行，每行给出一个玩家的信息：玩家号  号码牌  装备星级。其中玩家号由 14 位数字组成，号码牌从 1 到?N?编号。输入保证每个玩家号都不同。
玩家信息之后，给出一个正整数?M（≤N），随后一行中给出?M?个待查询的玩家号，以空格分隔。

### 输出格式:

对应每个需要查询的号码牌，在一行中输出对应的玩家号和装备星级，中间用 1 个空格分隔。

### 输入样例:

在这里给出一组输入。例如：

```in
4
10120150912233 2 4
10120150912119 4 1
10120150912126 1 3
10120150912002 3 2
2
3 4
```

### 输出样例:

在这里给出相应的输出。例如：

```out
10120150912002 2
10120150912119 1
```


答案：
#include<iostream>
using namespace std; 
int  main(void){
    int n;
    cin>>n;
    string *class_hao=new string[n];
    int *pai=new int[n];
    int *xing=new int[n];
    for(int i=0;i<n;i++){
        cin>>class_hao[i]>>pai[i]>>xing[i];

    }
    int num;
    cin>>num;
    int *c_xing=new int[num];
    for(int i=0;i<num;i++){
        cin>>c_xing[i];
    }
    for(int j=0;j<num;j++){
         for(int i=0;i<n;i++){
            if(pai[i]==c_xing[j]){
                cout<<class_hao[i]<<" "<<xing[i]<<endl;
                break;
            }
        }
    }
   

    return 0;
}

------------------------


题目16:
题目：查找单价最高和最低的书籍 10 分难度：7-65
正文：
编写程序，从键盘输入 n (n<10)本书的名称和定价并存入结构数组中，查找并输出其中定价最高和最低的书的名称和定价。

输出格式语句：

 printf("highest price: %.1f, %s\n", );

 printf("lowest price: %.1f, %s\n",);

输入输出示例：括号内为说明，无需输入输出

### 输入样例:
```in
3	(n=3)
Programming in C
21.5
Programming in VB
18.5
Programming in Delphi
25
```

### 输出样例:
```out
highest price: 25.0, Programming in Delphi 
lowest price: 18.5, Programming in VB 
```

答案：
#include<iostream>
#include<iomanip>
#include <string.h>
using namespace std;
struct Book
{
	double price;
	char name[31];
}book;

int main()
{
	int n;
	cin >> n;
	struct Book book[100];

	int i, max = 0, min = 0;
	for (i = 0; i<n; i++)
	{
		getchar();
		cin.getline(book[i].name, 31);
		cin >> book[i].price;
		if (book[i].price>book[max].price)
		{
			max = i;
		}
		if (book[i].price<book[min].price)
		{
			min = i;
		}
	}
	cout << "highest price: " << fixed << setprecision(1) << book[max].price << ", " << book[max].name << endl;
	cout << "lowest price: " << fixed << setprecision(1) << book[min].price << ", " << book[min].name;
	getchar();
	return 0;
}


------------------------


题目17:
题目：立方体类的实现 30 分难度：7-17
正文：
立方体类Box的实现，完成计算体积、计算表面积、输出结果等功能。其中给定的主函数为：

    int  main( ){
        float ab;
        cin>>ab;
        Box  obj;
        obj.seta( ab );
        obj.getvolume( );
        obj.getarea( );
        obj.disp( );
        return 0;
    }
### 输入格式:

立方体的边长，可以是float类型的数据。

### 输出格式:

立方体的体积和表面积，中间用一个空格隔开，末尾换行。

### 输入样例:
```in
3
```

### 输出样例:
```out
27 54
```

答案：
#include<iostream>
using namespace std;
class Box{
	private:
		float a;
		double volume;
		double area;
	public:
		void seta(float ab){
			a=ab;
		}
		void getvolume( ){
			volume=a*a*a;
		}
		void getarea(){
			area=a*a*6;
		}
		void disp(){
			cout<<volume<<" "<<area<<endl;
		}
		
};
int  main( ){
    float ab;
    cin>>ab;
    Box  obj;
    obj.seta( ab );
    obj.getvolume( );
    obj.getarea( );
    obj.disp( );
    return 0;
}

------------------------


题目18:
题目：设计一个矩形类Rectangle并创建测试程序（C++） 10 分难度：7-18
正文：
设计一个名为Rectangle的矩形类，这个类包括：两个名为width和height的double数据域，它们分别表示矩形的宽和高。width和height的默认值都为1.该类包括矩形类的无参构造函数（默认构造函数）；一个width和height为指定值的矩形构造函数；一个名为getArea( )的函数返回矩形的面积；一个名为getPerimeter( )的函数返回矩形的周长。请实现这个类。编写一个测试程序，创建一个Rectangle对象，从键盘输入矩形的宽和高，然后输出矩形的面积和周长。

### 输入格式:

3.5 35.9（第一个数表示矩形的宽，第二个数表示矩形的高，中间是空间分隔。）

### 输出格式:

125.65  （第一行输出矩形的面积）
78.8  （第二行输出矩形的周长）

### 输入样例:
```in
3.5 35.9
```

### 输出样例:
```out
125.65
78.8
```

答案：
#include<iostream>
using namespace std;
class Rectangle{
	private:
		double width,hight;
		double area,perimeter;
		
	public:
		Rectangle(double w=1,double h=1){
			width=w;
			hight=h;
		}
		Rectangle(){
			width=1;
			hight=1;
		}
		void  getArea(){
			cout<<width*hight<<endl;
		}
		double getPerimeter(){
			cout<<width*2+hight*2<<endl;
		}
		
};
int  main( ){
		
		double w,h;
		cin>>w>>h;
		Rectangle re(w,h);
		re.getArea();
		re.getPerimeter();
    return 0;
}

------------------------


题目19:
题目：复数类的操作 20 分难度：7-19
正文：
1、声明一个复数类Complex（类私有数据成员为double型的real和image） 

2、定义构造函数，用于指定复数的实部与虚部。

3、定义取反成员函数，调用时能返回该复数的相反数（实部、虚部分别是原数的相反数）。 

4、定义成员函数Print()，调用该函数时，以格式(real, image)输出当前对象。

5、编写加法友元函数，以复数对象c1，c2为参数，求两个复数对象相加之和。 

6、主程序实现： 

（1）读入两个实数，用于初始化对象c1。 

（2）读入两个实数，用于初始化对象c2。 

（3）计算c1与c2相加结果，并输出。 

（4）计算c2的相反数与c1相加结果，并输出。


### 输入格式:

输入有两行： 

第一行是复数c1的实部与虚部，以空格分隔； 

第二行是复数c2的实部与虚部，以空格分隔。

### 输出格式:

输出共三行: 

第一行是c1与c2之和；

第二行是c2的相反数与c1之和；

第三行是c2 。

### 输入样例:

在这里给出一组输入。例如：

```in
2.5 3.7
4.2 6.5
```

### 输出样例:

在这里给出相应的输出。例如：

```out
(6.7, 10.2)
(-1.7, -2.8)
(4.2, 6.5)
```


答案：


/*
1、声明一个复数类Complex（类私有数据成员为double型的real和image）
2、定义构造函数，用于指定复数的实部与虚部。
3、定义取反成员函数，调用时能返回该复数的相反数（实部、虚部分别是原数的相反数）。
4、定义成员函数Print()，调用该函数时，以格式(real, image)输出当前对象。
5、编写加法友元函数，以复数对象c1，c2为参数，求两个复数对象相加之和。
6、主程序实现：
（1）读入两个实数，用于初始化对象c1。
（2）读入两个实数，用于初始化对象c2。
（3）计算c1与c2相加结果，并输出。
（4）计算c2的相反数与c1相加结果，并输出。
输入格式:
输入有两行：
第一行是复数c1的实部与虚部，以空格分隔；
第二行是复数c2的实部与虚部，以空格分隔。
输出格式:
输出共三行:
第一行是c1与c2之和；
第二行是c2的相反数与c1之和；
第三行是c2 。
输入样例:
在这里给出一组输入。例如：
2.5 3.7
4.2 6.5







输出样例:
在这里给出相应的输出。例如：
(6.7, 10.2)
(-1.7, -2.8)
(4.2, 6.5)
*/
#include<iostream>
using namespace std;
class Complex{

public:
	Complex(double r, double i) :real(r), image(i){}
	Complex qufan(){
	return	Complex(-real,-image);
//		real=-real;
//		image=-image;
//		return *this;
	}
	void Print(){
		cout << "(" << real << ", " << image << ")" << endl;
	}
	friend Complex operator+(const Complex & a, const Complex &b);
private:
	double real, image;
};
Complex operator+(const Complex &a, const Complex &b) {
	return Complex(a.real + b.real, a.image + b.image);

}
int main(void){
	double ax, ay, bx, by;
	cin >> ax >> ay;
	cin >> bx >> by;
	Complex a(ax, ay);
	Complex b(bx, by);
	Complex c = a + b;
	
//	Complex x=b.qufan();
//
	c.Print();
	 
	Complex d = b.qufan() + a;
	d.Print();
	b.Print();


	return 0;
}

------------------------


题目20:
题目：宿舍谁最高？ 20 分难度：7-99
正文：
学校选拔篮球队员，每间宿舍最多有4个人。现给出宿舍列表，请找出每个宿舍最高的同学。定义一个学生类Student,有身高height，体重weight等。

### 输入格式:

首先输入一个整型数n （1<=n<=1000000），表示n位同学。  
紧跟着n行输入,每一行格式为：宿舍号，name,height,weight。  
宿舍号的区间为[0,999999]， name 由字母组成，长度小于16，height，weight为正整数。  

### 输出格式:

按宿舍号从小到大排序，输出每间宿舍身高最高的同学信息。题目保证每间宿舍只有一位身高最高的同学。

### 输入样例:
```in
7
000000 Tom 175 120
000001 Jack 180 130
000001 Hale 160 140
000000 Marry 160 120
000000 Jerry 165 110
000003 ETAF 183 145
000001 Mickey 170 115
```

### 输出样例:
```out
000000 Tom 175 120
000001 Jack 180 130
000003 ETAF 183 145
```

答案：
#include <iostream>
#include <iomanip>
#include<map>
#include<string>
using namespace std;
class Student{
public:
	int hige;
	int weight;
	string name;
};
int main(void){
	int n;
	cin >> n;
	Student stu;
	map<int, Student> mp;
	int hao;//宿舍号 
	for (int i = 0; i<n; i++){
		cin >> hao >> stu.name >> stu.hige >> stu.weight;
		if (stu.hige>mp[hao].hige ){
			mp[hao] = stu;//筛选最高
		}
	}
	//map<int, Student>::iterator it;
	for (auto it = mp.begin(); it != mp.end(); it++){
		cout << setw(6)<<setfill('0')<< it->first << " " << it->second.name << " " << it->second.hige << " " << it->second.weight << endl;
	}
	return 0;
}

------------------------


题目21:
题目：图书音像出租管理 10 分难度：7-121
正文：
一个图书音像店出租图书和磁带。  
给出下面一个基类的框架：  
class Publication  
{  
protected:  
string title;//名称  
float price;//原价  
int day;//租期  
public:  
virtual void display()=0;//打印价格清单  
}  
以Publication为基类，构建Book和Tape类。  
生成上述类并编写主函数，要求主函数中有一个基类Publication指针数组，数组元素不超过10个。  
Publication *pp[10];  
主函数根据输入的信息，相应建立Book, Tape类对象。  
它们的原始租金为：租期*1.2。  
另外，实际收取的租金不超过2倍的租品估价。  
Book的估价为：新旧程度*原价。  
Tape的估价为：原价/（1+已出租次数/3）。  
输入格式：每个测试用例占一行，第一项为租品类型，1为Book,2为Tape.接下来为名称、原价、租期。最后一项Book是新旧程度（0.1至1），Tape是已出租次数。以0表示输入的结束。  
要求输出名称，原始租金(小数点后保留1位小数)，如果原始租金大于2倍租品估价，则同时给出实际应收取的租金(小数点后保留1位小数)，并在最后标明R。  

输入样例  
1 AAA 19.5 3 0.5  
1 BBB 9.5 2 0.1  
2 AA 10 2 0  
2 DDDD 12.5 2 38  
1 FFF 42 3 0.1  
0  
输出样例  
AAA 3.6  
BBB 2.4 1.9 R  
AA 2.4  
DDDD 2.4 1.8 R  
FFF 3.6

答案：
#include<iostream>
#include<string>
#include<iomanip>
using namespace std;

class Publication
{
protected:
	string title;//名称
	float price;//原价
	int day;//租期
public:
	Publication(string name, float price_, int day_) :title(name), price(price_), day(day_){}
	virtual void display() = 0;//打印价格清单
};

class Book :public  Publication{////名称、原价、租期。最后一项Book是新旧程度
	float isnew;
public:
	Book(string name, float price_, int day_, float isnew_) :Publication(name, price_, day_), isnew(isnew_){

	}
	void display(){//它们的原始租金为：租期1.2。
	
		cout << title << " " << (day*1.2);
		if ((day*1.2) > (isnew*price * 2)){
			cout << " " << (isnew* price * 2) << " R" ;
		}
		cout << endl;
	}
};
class Tape :public Publication
{
	int nums;
public:
	Tape(string name, float price_, int day_, int isnew_) : Publication(name, price_, day_), nums(isnew_){}
	void display(){
		cout << title << " " << day*1.2;//原价/（1+已出租次数/3）。
		if ((day*1.2) > (price / (1 + nums / 3) * 2)){
		//	cout << (price / (1 + nums / 3) * 2) << " R" ;
			printf(" %.1f R",(price/(nums/3+1))*2.0);
		}

		cout << endl;
	}
};

int main(void){


	Publication *pp[10];
	int type;
	string name;
	float price;
	int day;
	int num;
	float isnew;
	int i = 0;
	while (cin >> type){
		if (type == 0){
			break;
		}
		else{
			if (type == 1){
				cin >> name >> price >> day >> isnew;
				pp[i++] = new Book(name, price, day, isnew);
			}
			else if (type == 2){
				cin >> name >> price >> day >> num;
				pp[i++] = new Tape(name, price, day, num);

			}


		}
	}
	for (int k = 0; k < i; k++){
		pp[k]->display();
	}
	return 0;
}


------------------------


题目22:
题目：体育俱乐部积分管理 10 分难度：7-122
正文：
一个俱乐部有篮球、足球和排球队。  
下面给出基类的框架：  
class Ball  
{  
protected:  
string opponent;//对手  
public:  
void display();//显示比赛成绩  
}  
以Ball为基类，构建Basketball, Football和Volleyball三个类。  
生成上述类并编写主函数，要求主函数中有一个基类Ball指针数组，数组元素不超过20个。  
Ball *pb[20];  
主函数根据输入的信息，相应建立Basketball, Football, Volleyball类对象。  
输入格式：每个测试用例占一行，第一项为类型，1为Basketball，2为Football，3为Volleyball, 第二项是对手名称，第二项是比分。输入0表示输入的结束。  
输出时，依次打印对手名称和该场积分数（以万元为单位）：Basketball胜一场得2分，负一场得1分；Football胜一场得3分，平一场得1分；排球以3：0或3：1胜时，得3分，以3：2胜时，得2分，以2：3负时，得1分，其它情况得0分。  

输入样例  
1 AAA 108:106  
2 BB 2:1  
3 CCC 3:2  
2 BB 2:2  
3 EEE 3:1  
3 FFF 2:3  
3 CCC 0:3  
1 AAA 95:99  
0  

输出样例  
AAA 2  
BB 3  
CCC 2  
BB 1  
EEE 3  
FFF 1  
CCC 0  
AAA 1

答案：
#include<iostream>
#include<string>
using namespace std;
class Ball
{
protected:
	string opponent;//对手
public:
	Ball(string s) :opponent(s){};
	virtual void display()=0;//显示比赛成绩
};
class Basketball :public Ball{
public:
	Basketball(string s, int so) :Ball(s), sco(so){};
	virtual void display(){
		
		if (sco > 0)
			cout << opponent << " " << 2 << endl;
		if (sco<0)
			cout << opponent << " " << 1 << endl;
	}
private:
	int sco;

};
class Football :public Ball{
public:
	Football(string s, int so) :Ball(s), sco(so){};
	virtual void display(){
		if (sco > 0)
			cout << opponent << " " << 3 << endl;
		if (sco==0)
			cout << opponent << " " << 1 << endl;
		if (sco<0)
			cout << opponent << " " << 0 << endl;
	}
private:
	int sco;
};
class Volleyball :public Ball{
public:
	Volleyball(string s, double so) :Ball(s), sco(so){};
	virtual void display(){
		//3：0或3：1胜时，得3分，以3：2胜时，得2分，以2：3负时，得1分，其它情况得0分。
		if (sco ==3.1||sco==3.0)
			cout << opponent << " " << 3 << endl;
		else if (sco == 3.2)
			cout << opponent << " " << 2 << endl;
		else if(sco == 2.3)
			cout << opponent << " " << 1 << endl;
		else if (sco==-1)
		{
			cout << opponent << " " << 0 << endl;
		}
	}
private:
	double sco;
};
int main(void){
	Ball *pb[20];
	int n;
	int count = 0;
	string s;
	int a1, a2;
	double sco;
	while (true)
	{
		
		cin >> n;
		if (n == 0){
			break;
		}
		cin >> s;
		scanf("%d:%d", &a1, &a2);
		
		if (n == 1){
		
			if (a1 > a2)
				sco = 1;
			else
				sco = -1;
			pb[count++] = new Basketball(s,sco);
		}
		else if (n==2)
		{
			
			if (a1 > a2)
				sco = 1;
			else if (a1 == a2)
				sco = 0;
			else if (a1 < a2)
				sco = -1;
			pb[count++] = new Football(s, sco);
		}
		else if (n==3)
		{
			
			//排球以3：0或3：1胜时，得3分，以3：2胜时，得2分，以2：3负时，得1分，其它情况得0分。 
			if (a1 == 3 && (a2 == 1 || a2 == 0))
				sco = 3.1;
			else if (a1 == 3 && a2 == 2)
				sco = 3.2;
			else if (a1 == 2 && a2 == 3)
				sco = 2.3;
			else
				sco = -1;

			pb[count++] = new Volleyball(s, sco);
		}

	}
	for (int i = 0; i < count; ++i){
		pb[i]->display();
		delete pb[i];
	}
	return 0;
}

------------------------


题目23:
题目：选择法排序 20 分难度：7-23
正文：
本题要求将给定的$$n$$个整数从大到小排序后输出。

### 输入格式：

输入第一行给出一个不超过10的正整数$$n$$。第二行给出$$n$$个整数，其间以空格分隔。

### 输出格式：

在一行中输出从大到小有序的数列，相邻数字间有一个空格，行末不得有多余空格。

### 输入样例：
```in
4
5 1 7 6
```

### 输出样例：
```out
7 6 5 1
```

答案：
#include<iostream>
#include<stdlib.h>
using namespace std;
int com(const void*a,const void* b){
	return *(int*)b - *(int*)a;
}
int main(){
	 int n=10;
	cin >> n;
	int num[n];
	for (int i = 0; i < n; i++){
		cin >> num[i];
	}
	qsort(num, n, sizeof(int), com);
	for (int i = 0; i < n-1; i++){
		cout << num[i] << " ";
	}
	cout<<num[n-1]; 
	return 0;
}

------------------------


题目24:
题目：三个整数之和 10 分难度：7-24
正文：
输入三个整数求和并输出。

### 输入格式:
在一行中输入3个整数，3个整数之间用一个空格间隔，没有其它任何附加字符。

### 输出格式:

在一行中按照“sum=结果”的顺序输出，其中结果为原样输出。

### 输入样例:
```in
4 5 6
```

### 输出样例:
```out
sum=15
```

答案：
#include<iostream>
#include<stdlib.h>
using namespace std;

int main(){
	int n[3];
	//cin>>n[1]>>n[2]>>n[3];
	for(int i=0;i<3;i++){
		cin>>n[i];
	}
	int *p[]={n,n+1,n+2};
	int **q=p;
	
	int sum=**q+**(q+1)+**(q+2);
	cout<<"sum="<<sum<<endl;
	return 0;
}

------------------------


题目25:
题目：抽象基类Shape派生3个类 15 分难度：7-25
正文：
声明抽象基类Shape,由它派生出三个类，圆形Circle，矩形Rectangle，三角形Triangle，用一个函数输出三个面积。

### 输入格式:

在一行中依次输入5个数，圆的半径，长方形的高和宽，三角形的高和底，中间用空格分隔

### 输出格式:

圆的面积，长方形的面积，三角形的面积，小数点后保留2位有效数字，每个面积占一行。

### 输入样例:

在这里给出一组输入。例如：

```in
3 3 4 3 4
```

### 输出样例:

在这里给出相应的输出。例如：

```out
28.27
12.00
6.00
```


答案：
#include<iostream>
using namespace std;
class Shape{
public:
virtual	void show() = 0;
};
class Circle :public Shape{
private:
	double r;
public:
	void set(double r_){
		r = r_;
	}
	virtual void show(){
		printf("%.2f\n", 3.1415926*r*r);
	}
};
class Rectangle :public Shape{
private:
	double a, b;
public:
	void set(double a_, double b_){
		a = a_;
		b = b_;
	}
	virtual void show(){
		printf("%.2f\n", a*b);
	}
};
class Triangle :public Shape{
private:
	double a, b;
public:
	void set(double a_, double b_){
		a = a_;
		b = b_;
	}
	virtual void show(){
		printf("%.2f\n", 0.5*a*b);
	}
};
int main(void){

	Circle c;
	Rectangle R;
	Triangle t;
	double r, a, b;
	cin >> r >> a >> b;
	c.set(r);
	R.set(a, b);
	cin >> a >> b;
	t.set(a, b);
	c.show();
	R.show();
	t.show();
	return 0;
}

------------------------


题目26:
题目：A-B 20 分难度：7-183
正文：
本题要求你计算$$A-B$$。不过麻烦的是，$$A$$和$$B$$都是字符串 ―― 即从字符串$$A$$中把字符串$$B$$所包含的字符全删掉，剩下的字符组成的就是字符串$$A-B$$。

### 输入格式：

输入在2行中先后给出字符串$$A$$和$$B$$。两字符串的长度都不超过$$10^4$$，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。

### 输出格式：

在一行中打印出$$A-B$$的结果字符串。

### 输入样例：
```in
I love GPLT!  It's a fun game!
aeiou
```

### 输出样例：
```out
I lv GPLT!  It's  fn gm!
```

答案：
#include <iostream>
#include <string>
#include <iomanip>
using namespace std;
int main(){
	string s1,s2;
	getline(cin,s1);
	getline(cin,s2);
	int size=s1.size();
	for(int i=0;i<size;++i){
		bool isfalg=1;
		for(int j=0;j<s2.length();++j){
			if(s1[i]==s2[j]){
				isfalg=0;
				break;
			}
		}
		if(isfalg)
			cout<<s1[i];
	}
	
	
	return 0;
}

------------------------


题目27:
题目：学号解析 10 分难度：7-184
正文：
川师的学号的某些位有特殊的含义，如从2016110101中可以看出该学生为2016级，就读于11系，班级为1班。根据输入的学号，利用程序进行解析，输出对应的信息。

### 输入格式:

一个学号

### 输出格式:

相关信息

### 输入样例:

在这里给出一组输入。例如：

```in
2016110101
```

### 输出样例:

在这里给出相应的输出。例如：

```out
year:2016
department:11
class:01

```


答案：
#include <iostream>
#include <string>
#include <iomanip>
using namespace std;
int main(){
	string s1;
	cin>>s1;
	cout<<"year:"<<s1.substr(0,4)<<endl;
	cout<<"department:"<<s1.substr(4,2)<<endl;
	cout<<"class:"<<s1.substr(6,2)<<endl;
	return 0;
}

------------------------



